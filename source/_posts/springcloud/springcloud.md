# 一、面试题

##1.什么是微服务？

```

```



##2.微服务之间是如何独立通讯的？

```

```



##3.springcloud和dubbo有哪些区别？

```
dubbo：基于RPC,SpringCloud:基于Restful API
```

|        | Dubbo     | Spring Cloud |
| ------ | --------- | ------------ |
| 服务注册中心 | zookeeper | eureka       |
| 服务调用方式 | RPC       | RestAPI      |
| 服务监控   | monitor   | Admin        |
| 断路器    | 不完善       | Hystrix      |
| 服务网关   | 无         | Zuul         |
| 分布式配置  | 无         | Config       |
| 服务跟踪   | 无         | Sleuth       |
| 消息总线   | 无         | Bus          |
| 数据流    | 无         | Stream       |
| 批量任务   | 无         | Task         |



##4.springboot和springcloud，请你谈谈对他们的理解

```

```



##5.什么是服务熔断？什么是服务降级？

```

```



##6.微服务的优缺点分别是什么？说下你再项目开发中碰到的坑?

```

```



##7.你所知道的微服务技术栈有哪些？请列举一二

| 微服务条目   | 落地技术                         | 备注   |
| ------- | ---------------------------- | ---- |
| 服务开发    | SpringBoot,Spring,SpringMVC  |      |
| 服务配置与管理 | Neflix公司Archaius、阿里的Diamond等 |      |
| 服务注册与发现 | Eureka、Consul、Zookeeper等     |      |
| 服务调用    | Rest、RPC、gRPC                |      |
| 服务熔断器   | Hystrix、Envoy等               |      |
| 负载均衡    | Ribbon，nginx等                |      |
| 服务接口调用  | feign                        |      |
| 消息队列    | kafka、RabbitMQ               |      |
|         |                              |      |



## 8.eureka和zookeeper都可以提供服务注册和发现的功能，说下两者的区别

```

```

# 二、微服务概述

## 1、什么是微服务

将单一的应用程序划分成一组小的服务，每个服务运行在其独立的进程，服务之间互相协调，互相配合。

服务之间采用轻量级的通信机制进行沟通。

可以使用不同语言来编写服务

```
微服务化的核心就是将传统的一站式应用，根据业务拆分成一个个的服务，彻底地去耦合，每一个微服务提供单个业务功能，一个服务做一件事情。从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或者销毁，拥有自己独立的数据库。
```

## 2、微服务优缺点

###1、优点

```

```



### 2、缺点

# 三、学习资料

[SpringCloud中文网](https://www.springcloud.cc/)

[SpringCloud中文社区](springcloud.cn)

# 四、Spring Cloud

## 1、Eureka

### 1、自我保护机制：好死不如赖活着

```
某时刻某一个微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存

默认情况下，EurekaServer在规定时间内没有收到客户端发来的心跳，会将该客户端从服务注册表中删除。但是当一段时间内出现大量的客户端不发送心跳，Eureka就进入自我保护模式，进入自我保护模式后，客户端的信息会被保存下来。

默认情况下，如果Eureka在一定时间内没有收到某个微服务实例的心跳，EurekaServer将会注销该实例，默认是90秒。但是当网络分区故障时，微服务与EurekaServer之间不能通信，以上行为可能变得非常危险：因为微服务本身是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护机制”来解决这个问题————当EurekaServer节点在短时间内丢失过多的客户端时（可能发生了网络故障），那么这个节点就会进入自我保护模式。一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不会删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复时，该EurekaServer自动退出自我保护模式。


```

### 2、配置

### 3、eureka属于客户端发现

eureka属于客户端服务发现，

nginx，zookeeper，k8s属于服务端发现

服务端发现的组件会作为代理使用

## 2、Ribbon:客户端负载均衡，进程内LB

面试题：Ribbon，feign，nginx都可以做负载均衡，区别是什么？

```
feign融合了ribbon
```

### 1、负载均衡(Load Balance)

**负载均衡简单说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA.**

负载均衡分**集中式LB**，**进程内LB**

**集中式LB** ： 偏硬件，在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5,也可以是软件，如nginx），由该设施负责把访问请求通过某种策略转发到服务的提供方。

**进程内LB** ：偏软件，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。

**Ribbon就属于进程内LB，**它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。

### 2、负载均衡算法

#### 自定义负载均衡算法

**可以作为项目中遇到的坑**：自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，也就是说我们达不到特殊定制化的目的。

## 3、feign

## 4、hystrix

hystrix是在客户端调用的

### 服务熔断

```
多个微服务有依赖关系，其中一个微服务挂掉，为了避免影响依赖于这个微服务的其他微服务，需要使用服务熔断。

一般是某个服务故障或异常引起，类似现实世界中的“保险丝”，当某个异常条件被触发时，直接熔断整个服务，而不是一直等到此服务超时。
```

### 服务雪崩

```

```



### 服务降级

```
整体资源快不够了，忍痛将某些服务先关掉，待度过难关，再重启回来。

服务降级是在客户端完成的，与服务端没有关系。

所谓降级，一般是从整体负荷考虑，就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己装一个本地的fallback回调，返回一个缺省值。这样做，虽然服务水平下降，单好歹可用，比直接挂掉要强。

```

### 使用

@HystrixCommond

@EnableCircuitBreaker



## 5、Zuul

```
请求的路由和过滤

```

@EnableZuulProxy



```
zuul:
 prefix: /atguigu                           #统一前缀
 ignored-services: microservicecloud-dept  #屏蔽真实名称
 # ignored-services: "*"    #屏蔽所有的真实名称
 routes:
  mydept.serviceId: microservicecloud-dept
  mydept.path: /mydept/**
```

## 6、Config

作用：

1.集中管理文件

2.不同环境不同配置，动态化的配置更新，分环境部署

3.运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息

4.当配置发生变动时，服务不需要重启即可感知配置的变化并应用新的配置

5.将配置以REST接口的形式暴露



**application.yml和bootstrap.yml**

```
application.yml是用户级的资源配置项
bootstrap.yml是系统级的，优先级更加高
```

Devops:开发自运维

图片存储：FastFS