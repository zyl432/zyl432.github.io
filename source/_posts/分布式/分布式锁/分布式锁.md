# 一、应用场景

同一个服务的不同实例同时请求操作数据库

# 二、实现

## 1. 使用redis实现分布式锁

### Redisson框架

原理：

发送lua脚本到redis进行加锁，加锁成功后，watchdog，也就是redission框架后台执行一段逻辑，每个10s去检查这个锁是否还被当前客户端持有，如果是的话，重新刷新一下key的生存时间为30s；

### 面试问题

* 如果Redis是集群部署的，那么集群故障时分布式锁还有效吗？

会有，redis的master向slave同步数据是异步的，会有延迟，如果master挂掉，slave成为master以后，其他服务过来加锁，会重复加锁。

比较难解决，需要修改redis或者redisson源码，保证master和slave同时写入成功。

##2. 使用zookeeper实现分布式锁

zookeeper四种节点：

zookeeper的临时节点的有序特性

zookeepr的watch特性，节点被删除会监听到

## 3. 使用专门的数据库

使用唯一约束

create_table lock(

id,

method_name(唯一约束),

....

);

通过删除记录来清除锁

####问题：

1.如果删除失败，会导致死锁

2.不是重入锁：可以通过增加服务id判断