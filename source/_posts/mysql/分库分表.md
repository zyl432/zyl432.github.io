## 1.为什么要分库分表？

单表存储超过一千万，就会影响性能。单表请求超过2000，就会扛不住。

分库和分表是两个概念

## 2.用过哪些分库分表中间件？不同的分库分表中间件都有哪些优点和缺点？

cobar：proxy层

TDDL:client层

atlas：proxy层

**用的比较多的：**

sharding-jdbc：client层，不需要部署，运维成本低，缺点是各个系统耦合了sharding-jdbc，升级时所有系统都要重新发布

mycat：proxy层，独立部署，运维成本高，方便升级

##3.你们具体是如何对数据库进行垂直拆分或水平拆分？

垂直拆分：

水平拆分：

## 4.现在有一个未分库分表的系统，未来要分库分表，如何设计才可以让系统从未分库分表动态切换到分库分表上？

sharding-jdbc：找一个最基本的例子，学习一下

mycat：学习例子

（1）停机分库分表

缺点：

​	1.系统停机

​	2.中途出问题，停机时间内没搞定，就得回滚，第二天继续搞

​	3.开发需要加班

（2）双写迁移方案

同时往单库和新库中写数据

## 5.动态扩容缩容的方案？

 （1）设定好几台数据库服务器，每台服务器上几个库，每个库多少张表，推荐是32库* 32表，对于大部分公司莱索，可能几年都够了

（2）路由的规则，orderid%32=库的id，orderid%32=表的id

（3）扩容的时候，申请增加更多的数据库服务器，装好mysql，倍数扩容，4台服务器，扩到8台服务器，16台服务器

（4）由dba负责将原先的数据库服务器的库，迁移到新的数据库服务器上去，很多工具，库迁移，比较便捷

（5）我们这边就是修改一下配置，调整迁移的库所在数据库服务器的地址

（6）重新发布系统，上线，原来的路由规则变都不用变，这几可以基于2倍的数据库的资源，继续进行线上系统的提供服务

##6.分库分表之后，id主键如何生成？

（1）基于专门的数据库的自增id

好处简单

缺点，性能会有瓶颈

（2）UUID

（3）使用当前时间

（4）snowflake算法

64位的long型的id，64位的long->二进制

```
0 | 0001100 10100010 10111110 10001001 01011100 00 | 10001 | 1 1001 | 0000 00000000
依次是：
0（固定位）
时间
机房id
机器id
序号

```



