{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/3-hexo/source/img/5945805.jpg","path":"img/5945805.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":1,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/3-hexo/.gitignore","hash":"560a43fddfe4559ed1a17e7362874454519f189b","modified":1568291931143},{"_id":"themes/3-hexo/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1568291931107},{"_id":"themes/3-hexo/.git/config","hash":"e0bfd9b35852beab6bb3aa547e10d0805cbdf751","modified":1568291931125},{"_id":"themes/3-hexo/.git/index","hash":"7703fa61ac7205a967c15fc17e9753a98790348d","modified":1568292604499},{"_id":"themes/3-hexo/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1568291858624},{"_id":"themes/3-hexo/.git/packed-refs","hash":"831568bf16f063f9646e73003eae816edf7b173d","modified":1568291931093},{"_id":"themes/3-hexo/README.md","hash":"08c51fcae61d2e7e2af089712ce147324e4b6873","modified":1568291931143},{"_id":"themes/3-hexo/_config.yml","hash":"6a11e7a40023d6b8e3cccdd8e5cbefc2697bac81","modified":1568340217684},{"_id":"themes/3-hexo/.DS_Store","hash":"0770f9d42bfdd8d420de48fed463015e001cf579","modified":1568291931142},{"_id":"themes/3-hexo/layout/index.ejs","hash":"a5c464897e7dc9d45d03d8b61e742b1ac4173a95","modified":1568291931161},{"_id":"themes/3-hexo/layout/post.ejs","hash":"aeda285031ba8d4e94225e82b364bcf5f79fce1d","modified":1568291931163},{"_id":"themes/3-hexo/layout/indexs.md","hash":"a105822fb8e6c53cf17a9cc1a05d33ab2950c304","modified":1568294467455},{"_id":"source/_posts/JVM/JDK的命令行工具.md","hash":"c7ad1b0a77eb30e56ebd8b9570b3e488bf7c6873","modified":1572525293840},{"_id":"source/_posts/JVM/JVM参数.md","hash":"7deec3236df46cf1531b956dd1cbbc024d071a22","modified":1572441456139},{"_id":"source/_posts/JVM/JVM面试题.md","hash":"ffe74593218e7918f553af1f77b7cdd7fa3e568f","modified":1572438976008},{"_id":"source/_posts/JVM/内存溢出.md","hash":"17465ce909369cfc0779610af311f73190988c20","modified":1572869865840},{"_id":"source/_posts/linux/命令.md","hash":"69db0bceb89fa0e782c605d17ffef3175dd3af98","modified":1573654031574},{"_id":"source/_posts/javabase/static.md","hash":"389662e21c78ed4fafe0a6c80ff52b2c8c407f45","modified":1568338853672},{"_id":"source/_posts/multiThread/threadLifeCycle.md","hash":"09037ceac0f7a472a41d4fa23a4fe6f8e8343221","modified":1568298130370},{"_id":"source/_posts/mybatis/binding模块.md","hash":"da92ebc990da925cd5c2bec47cb4a820db34546a","modified":1568815137703},{"_id":"source/_posts/javabase/异常.md","hash":"24c591f6d991617911ab95df87d2a3056d037853","modified":1570797255173},{"_id":"source/_posts/mysql/index.md","hash":"6677d3fb3d206d7f1fc0379281f95c0d2241df9f","modified":1570797295043},{"_id":"source/_posts/springboot/Springboot优点.md","hash":"cd54dee2206850c2fe8ca99ffb19f37788f0cdd3","modified":1573363326580},{"_id":"source/_posts/springboot/自定义starter.md","hash":"b211394565553a7bd00eab920c62a63bb7af4f50","modified":1573274979038},{"_id":"source/_posts/springboot/Spring Boot.md","hash":"22ff276429842cb61b1bd319cc58730bee87f583","modified":1573994052658},{"_id":"source/_posts/spring/SpringMVC.md","hash":"f8ddbb34b694e24c1d71c1b09ea540d01c91c90d","modified":1572525497945},{"_id":"source/_posts/spring/Spring组件.md","hash":"62f256c5c5f6e9b015079e26689ac6783cba6da6","modified":1568338649190},{"_id":"source/_posts/spring/spring中的设计模式.md","hash":"55f8a13cba2c92e00899536b5e4f4f0c4a3dad3a","modified":1568504003264},{"_id":"themes/3-hexo/source/.DS_Store","hash":"fdcc907c46e093a14b153c5dc8c038461997ed3c","modified":1568291931165},{"_id":"source/_posts/spring/AOP底层源码.md","hash":"75fb4b351f9aecbfdd8458ff37e8ad8471b75608","modified":1568504020162},{"_id":"source/_posts/springcloud/springcloud.md","hash":"a794c88e01fc14ef158f1ca65a37d9c481dd7a66","modified":1574517983042},{"_id":"source/_posts/容器/HashMap面试题整理.md","hash":"4824c0e94a52cfcf549c389b44152a669b2dbe9c","modified":1572177308010},{"_id":"source/_posts/搭建博客/搭建博客.md","hash":"7b756b4ac4ac5f4d354dcae4694b930b50533311","modified":1572263665697},{"_id":"source/_posts/消息队列/消息队列.md","hash":"87002b97bcfb4c0068b6957b1d8b43ab8cbbdae9","modified":1574942844550},{"_id":"source/_posts/缓存/数据类型.md","hash":"67bc0891f7eb712718a5f4dffe8f7b8ac8be1e3c","modified":1574690435808},{"_id":"source/_posts/缓存/缓存.md","hash":"9c7c66f9c80bfcf6e0f8d155a82ad8da498166b5","modified":1574770184404},{"_id":"source/_posts/网络/网络基础.md","hash":"e47b2dacbba40339d1bd5da8dea2cf3f80d96249","modified":1570794953448},{"_id":"source/_posts/面试/Thoughtworks面试经历.md","hash":"63c4711787993ba0d735e8244922d89b450d516e","modified":1574770236750},{"_id":"source/_posts/面试/框架面试题整理.md","hash":"790726e34645720db343560ce7895bdd414e8f76","modified":1574778660846},{"_id":"source/_posts/spring/transaction.md","hash":"1d94c0fc28defc723263149fd557b897c8f47292","modified":1568338671622},{"_id":"source/_posts/mybatis/mybatis中的设计模式.md","hash":"0bbed3d26ffc8df63e964abbc02cd2a738a1717b","modified":1568342439588},{"_id":"source/_posts/mybatis/mybatis核心流程.md","hash":"193f7104e2acdcd8b02c19f78cdc49cebc386ee0","modified":1568634452930},{"_id":"source/_posts/mybatis/mybatis使用.md","hash":"662f79148b29038c86cc369688382dae738d0012","modified":1569415421673},{"_id":"source/_posts/设计模式/代理模式.md","hash":"b823f2907fbc60cfd172fd9afbbd6f1dac834359","modified":1568464609272},{"_id":"source/_posts/设计模式/建造者模式.md","hash":"d69b6d9bf01611e8f161bcf8d1bd944f018bfee6","modified":1568556495124},{"_id":"source/_posts/设计模式/策略模式.md","hash":"d19123875e43dd167a90706f6c30c5dcc4a77736","modified":1568817271249},{"_id":"source/_posts/设计模式/模板模式.md","hash":"2b69bfff5fcb09e3ea1fe70dc014af45263fceff","modified":1568898236093},{"_id":"themes/3-hexo/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1568291858640},{"_id":"themes/3-hexo/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1568291858626},{"_id":"source/_posts/设计模式/装饰器模式.md","hash":"82f5eb00c1090d5c3961bb8091f363520860044f","modified":1568505043990},{"_id":"source/_posts/spring/声明式事务底层源码.md","hash":"b16c248e6abf5c28b22111c113a8e4014b45c0e1","modified":1568338720088},{"_id":"themes/3-hexo/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1568291858629},{"_id":"themes/3-hexo/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1568291858630},{"_id":"source/_posts/multiThread/阻塞队列.md","hash":"3a2ce259752b62ede068222c5ec54dcd53004d5b","modified":1568813725121},{"_id":"themes/3-hexo/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1568291858628},{"_id":"themes/3-hexo/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1568291858636},{"_id":"themes/3-hexo/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1568291858632},{"_id":"themes/3-hexo/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1568291858634},{"_id":"themes/3-hexo/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1568291858627},{"_id":"themes/3-hexo/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1568291858633},{"_id":"themes/3-hexo/.git/logs/HEAD","hash":"014ba2d28893bfb32a636b6142d5e1cc97e96470","modified":1568291931115},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1568291931147},{"_id":"themes/3-hexo/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1568291858637},{"_id":"themes/3-hexo/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1568291858638},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"05d3cddf5f3a53577452db4efa811bd361f7c0c4","modified":1568291931147},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"faffe25aec33936fa2ec9d8f0e34e16ef3d90c25","modified":1568291931152},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"558a3d4bad578819fb07729fe1b50d9b81da8b93","modified":1568291931155},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"0e976208d79b0396eb51ca1af5016c963c6e4618","modified":1568291931155},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"84cf0f001afe58574e983a1c42a3710b10427cca","modified":1568291931146},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"6eab1e5fae6bd60928325d026a1bed61c43d11a9","modified":1568291931152},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1568291931157},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"311489fe2050ada8a0eaad3d0c57e5d5012f470e","modified":1568291931154},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"87e932476754f27424f9ec397ed66a4ab8a59ad8","modified":1568291931159},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1568291931160},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ef387e80043b62e1925a068267f2377cac64adc7","modified":1568291931157},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"c14bc1393f779dff7854089621804dceea236d82","modified":1568291931158},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"915d5f10dd8f3dcd19cb75010e23689e8f385caf","modified":1568291931156},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"98326675546fc6828a45e8b95250899b4ee2d821","modified":1568291931159},{"_id":"themes/3-hexo/source/img/5945805.jpg","hash":"376e28d8461a6087c32927cdc937a98bec544604","modified":1568297138980},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"d10bdd736aa343f38fe15cba4c81d45d3d259de4","modified":1568291931197},{"_id":"themes/3-hexo/source/css/style.styl","hash":"322abe325d5fe9ff37347bdd19e772315a8ebfed","modified":1568291931198},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1568291931201},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1568291931204},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"e457d1d3dfefbbd824d154cf756a2c6d10b812a2","modified":1568291931199},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"3dc58e9a3fd63a3144d5fe850eb55e3dc885c9fb","modified":1568291931184},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1568291931203},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1568291931202},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"2462169ad7f4a8ae9f9f4063995cbe7fed45cd77","modified":1568291931213},{"_id":"themes/3-hexo/source/js/search.js","hash":"788c610149a5f9361295f9f0207c8523f37ddb8b","modified":1568291931216},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1568291931212},{"_id":"source/_posts/JVM/assests/jmap-heap.png","hash":"1023c14eda9d55b9ec3cbd0ab4e5255a1c7c47b0","modified":1572266833560},{"_id":"source/_posts/springboot/images/AcceptLanuage.png","hash":"db02b4ca30721a52b29a8cbd3e37e561f7e4e4a5","modified":1573565611480},{"_id":"source/_posts/springboot/images/jquery-webjars.jpg","hash":"bb8be173b82a15ae1ee58070e81376b50b7fc626","modified":1573479032426},{"_id":"source/_posts/springboot/images/自动配置类.png","hash":"066009adefcfbc26b5e44734f9c151b3692f2490","modified":1573375151553},{"_id":"source/_posts/消息队列/images/exchange-fanout.png","hash":"5c4f7d43d9f1d8d5b69e7b830aa3fdedac9b5939","modified":1574943039813},{"_id":"source/_posts/消息队列/images/mq-1.png","hash":"a70a09ac2eeebda17a63be2a7fde7c033da46e88","modified":1574598375390},{"_id":"themes/3-hexo/source/js/script.js","hash":"14772b08b9c3d5c99a4b54748be9666deaae2778","modified":1568291931215},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"8dafb22561698d0758fba9ea2a45abf6ad3512a2","modified":1568291931206},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1568291931149},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"8a3a175c2da956366ce91bfc4f4012a487f4bdfc","modified":1568291931149},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"01567e010cf4f2dd141fe2019490d3f0d5aa2529","modified":1568291931151},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"908d9046502612d24780ca354bd9392a009b4d7b","modified":1568291931150},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"8c2a4f10a4da3d9615a3a81542494c6d21479b3d","modified":1568291931214},{"_id":"themes/3-hexo/.git/refs/heads/master","hash":"d1cb0a4250b33432dac3ef5ad50a3eb8d3b633ff","modified":1568291931114},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"eaf2b6f297282606b630ad55fb9e38af7e2829dc","modified":1568291931151},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"fe00fb1269b4fe1f3d5ab917891926222ce47275","modified":1568291931167},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"1ffe51e3b77afefcd94d386a718506d5b055ad94","modified":1568291931166},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"c200f3fabcfe83f3e45746e186b4bb111e73ad47","modified":1568291931169},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1568291931168},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"bf29eab9ea75fa191d678b6eefec440505ddf6e3","modified":1568291931171},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1568291931168},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1568291931173},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"4102753dad0cc1ee9ed673f7253ba097a960c3b7","modified":1568291931170},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"f7ef35459ece22e1da950b86126be1c2bfe97fcf","modified":1568291931173},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1568291931178},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"b7a74bdfe5f56d55f5485ac9026471fe701dbd82","modified":1568291931174},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"1d01247f974b059d9ef6a2178a724b4f72acd659","modified":1568291931172},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1568291931177},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1568291931176},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1568291931176},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1568291931182},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1568291931182},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1568291931180},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1568291931179},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1568291931186},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1568291931187},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1568291931188},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1568291931190},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1568291931191},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1568291931188},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1568291931189},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1568291931192},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1568291931192},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1568291931193},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1568291931193},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1568291931194},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1568291931195},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1568291931195},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1568291931196},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1568291931182},{"_id":"source/_posts/springboot/images/concrete-bindings.png","hash":"0fe2b1c98a91728475bc3510c594c710da424a4d","modified":1573472783745},{"_id":"source/_posts/消息队列/images/exchange-direct.png","hash":"e805cb92bcbc544657b444045fe0b0e1a01c65f3","modified":1574942959618},{"_id":"themes/3-hexo/.git/objects/pack/pack-bfe66738f5da00bb8ee1c84af22a609224c65fa3.idx","hash":"f3f9c2545075c9ab637b42ecee66d0017e42f23b","modified":1568291930924},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1568291931186},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"67984b83cd46ff4300d4fd959bf6c17dd66b4136","modified":1568291931211},{"_id":"themes/3-hexo/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1568291931104},{"_id":"themes/3-hexo/.git/logs/refs/heads/master","hash":"014ba2d28893bfb32a636b6142d5e1cc97e96470","modified":1568291931117},{"_id":"source/_posts/springboot/images/legacy.png","hash":"76ca2c12cf62aa09f4ec84deb35e9cc0cff228d0","modified":1573473832601},{"_id":"themes/3-hexo/.git/logs/refs/remotes/origin/HEAD","hash":"014ba2d28893bfb32a636b6142d5e1cc97e96470","modified":1568291931103},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"536f28c4354a13582af826d9d9b2cb27cec07dc6","modified":1568291931209},{"_id":"themes/3-hexo/.git/objects/pack/pack-bfe66738f5da00bb8ee1c84af22a609224c65fa3.pack","hash":"bb991e92785a07229b5cf1ba80b8da386587cb4f","modified":1568291931000},{"_id":"public/2019/11/26/面试/框架面试题整理/index.html","hash":"905a665441d63650c86e2f2465011eca823eb953","modified":1574943553231},{"_id":"public/2019/11/25/缓存/缓存/index.html","hash":"94317add871ce4e37f402c07ef708c65b175fb68","modified":1574943553231},{"_id":"public/2019/11/24/消息队列/消息队列/index.html","hash":"a89aabd45c28885db5272c760602a0149352aba7","modified":1574943553231},{"_id":"public/2019/11/18/springcloud/springcloud/index.html","hash":"949b8590901da662e0cba577ee3acd42e846ab1e","modified":1574943553231},{"_id":"public/2019/11/13/linux/命令/index.html","hash":"ccfa023636e834f2507e21ae2c4e3be74c16d63a","modified":1574943553232},{"_id":"public/2019/11/10/springboot/Springboot优点/index.html","hash":"d57021b99de88f97a87e2ffd04c5e54a3ddd3bdf","modified":1574943553232},{"_id":"public/2019/11/09/springboot/自定义starter/index.html","hash":"a1c5c07e1841cda59ccfa31047b980c99907d337","modified":1574943553232},{"_id":"public/2019/11/04/面试/Thoughtworks面试经历/index.html","hash":"c42ee614514f261551b487408abb8938d8e32b93","modified":1574943553232},{"_id":"public/2019/10/31/spring/SpringMVC/index.html","hash":"e063b248a571a3bb0bb0278a955a0e3382f9047d","modified":1574943553232},{"_id":"public/2019/10/30/JVM/JDK的命令行工具/index.html","hash":"5021086309729bfe5768e75c9b1f4cee59493a8d","modified":1574943553232},{"_id":"public/2019/10/30/JVM/JVM参数/index.html","hash":"fca92935a927db66209ae6d850b5fe08b2e8ae8b","modified":1574943553232},{"_id":"public/2019/10/30/JVM/JVM面试题/index.html","hash":"dd515579a114052f080bde1ce24cd0629c8cc688","modified":1574943553232},{"_id":"public/2019/10/28/JVM/内存溢出/index.html","hash":"9f68ee3a9e855272f5926897bae2a36a8e939952","modified":1574943553232},{"_id":"public/2019/10/27/容器/HashMap面试题整理/index.html","hash":"9281ff7f1f11e12ec1c67070dbdd657fc8b1812f","modified":1574943553232},{"_id":"public/2019/10/11/javabase/异常/index.html","hash":"b04093b7a14fdd6e1b76a275af916f1a81742782","modified":1574943553232},{"_id":"public/2019/09/25/mybatis/mybatis使用/index.html","hash":"555c07751cfb151687d5944539b73eb7dea7eee1","modified":1574943553233},{"_id":"public/2019/09/19/设计模式/模板模式/index.html","hash":"29e786f65e7bd23fe16499943233c795b1f7d6ec","modified":1574943553233},{"_id":"public/2019/09/18/设计模式/策略模式/index.html","hash":"695d8aa1205cca018d290b69c262bb12b6c62224","modified":1574943553233},{"_id":"public/2019/09/18/mybatis/binding模块/index.html","hash":"a439658d22c469b6748130669c6dd621258a2dd9","modified":1574943553233},{"_id":"public/2019/09/17/multiThread/阻塞队列/index.html","hash":"1899cdf022661592bfc8792d44c16d8b7ce2d317","modified":1574943553233},{"_id":"public/2019/09/16/mybatis/mybatis核心流程/index.html","hash":"4009e2c95f220199a6ecbd5716bb1cd6c400a897","modified":1574943553233},{"_id":"public/2019/09/15/设计模式/建造者模式/index.html","hash":"fb2ffe7a8d9c44366c8c4b130d7d98c474243ee8","modified":1574943553233},{"_id":"public/2019/09/15/设计模式/装饰器模式/index.html","hash":"5535c6f8fe50f862cd3bdd7c6246a786fd8a2594","modified":1574943553233},{"_id":"public/2019/09/14/设计模式/代理模式/index.html","hash":"94b63de03b25debc16c5f4f348f2a5f4b2e3c741","modified":1574943553233},{"_id":"public/2019/09/13/mybatis/mybatis中的设计模式/index.html","hash":"d26aaebe56eddf05a85cbe59a5709569d31c3038","modified":1574943553233},{"_id":"public/2019/09/13/搭建博客/搭建博客/index.html","hash":"48305cd2d9d87b80339ab493601640859fd8edc2","modified":1574943553234},{"_id":"public/2019/09/12/spring/声明式事务底层源码/index.html","hash":"3dbfa4eb56491310a9d1ff60c7f3fd48d2ec760c","modified":1574943553234},{"_id":"public/2019/09/12/spring/transaction/index.html","hash":"fa184ba2447ea960cf8ee58f774cfcb3db1bb5b0","modified":1574943553234},{"_id":"public/2019/09/12/spring/Spring组件/index.html","hash":"ee2b6f11d6f9634252a6ade5d7955eb0bba12a58","modified":1574943553234},{"_id":"public/2019/09/12/spring/spring中的设计模式/index.html","hash":"563e014b5d68df63a4b5dbf87bb535f4be65e77c","modified":1574943553234},{"_id":"public/2019/09/12/spring/AOP底层源码/index.html","hash":"85a3626bfc319b5fb592f259c6f9dc8a27d13fb0","modified":1574943553234},{"_id":"public/2019/09/12/缓存/数据类型/index.html","hash":"acc21665d5362f7fe5ab6c2967db41d703e520cd","modified":1574943553234},{"_id":"public/2019/09/12/mysql/index/index.html","hash":"3f0e3d2b296f83bc6d7d2f06fa5cff98cf5a463b","modified":1574943553234},{"_id":"public/2019/09/12/multiThread/threadLifeCycle/index.html","hash":"0248b0761ba5f1062a050530f9131bb3a0c73b46","modified":1574943553234},{"_id":"public/2019/09/12/网络/网络基础/index.html","hash":"a2f02b8e4c5be7ac7b01bad7a22b638560738957","modified":1574943553234},{"_id":"public/2019/09/12/javabase/static/index.html","hash":"a677c964274c94f58067c3b09b28d3d97e4ddf84","modified":1574943553235},{"_id":"public/archives/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553235},{"_id":"public/archives/page/2/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553235},{"_id":"public/archives/page/3/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553235},{"_id":"public/archives/page/4/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553235},{"_id":"public/archives/2019/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553235},{"_id":"public/archives/2019/page/2/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553235},{"_id":"public/archives/2019/page/3/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553235},{"_id":"public/archives/2019/page/4/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553235},{"_id":"public/archives/2019/09/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553235},{"_id":"public/archives/2019/09/page/2/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553236},{"_id":"public/archives/2019/09/page/3/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553236},{"_id":"public/archives/2019/10/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553236},{"_id":"public/archives/2019/11/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553236},{"_id":"public/categories/JVM/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553236},{"_id":"public/categories/java基础/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553236},{"_id":"public/categories/并发编程/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553236},{"_id":"public/categories/mybatis/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553236},{"_id":"public/categories/mysql/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553236},{"_id":"public/categories/spring/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553237},{"_id":"public/categories/博客搭建/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553237},{"_id":"public/categories/容器/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553237},{"_id":"public/categories/缓存/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553237},{"_id":"public/categories/网络/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553237},{"_id":"public/categories/面试/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553237},{"_id":"public/categories/设计模式/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553237},{"_id":"public/page/2/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553237},{"_id":"public/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553237},{"_id":"public/page/3/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553238},{"_id":"public/page/4/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553238},{"_id":"public/tags/JDK的命令行工具/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553238},{"_id":"public/tags/面试题/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553238},{"_id":"public/tags/JVM参数/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553238},{"_id":"public/tags/内存溢出/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553238},{"_id":"public/tags/java基础/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553238},{"_id":"public/tags/线程/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553239},{"_id":"public/tags/mybatis/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553239},{"_id":"public/tags/异常/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553239},{"_id":"public/tags/mysql/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553239},{"_id":"public/tags/spring/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553239},{"_id":"public/tags/设计模式/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553239},{"_id":"public/tags/AOP/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553239},{"_id":"public/tags/博客搭建/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553239},{"_id":"public/tags/HashMap/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553239},{"_id":"public/tags/缓存/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553240},{"_id":"public/tags/网络基础/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553240},{"_id":"public/tags/框架-面试题/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553240},{"_id":"public/tags/阻塞队列/index.html","hash":"62d2eebab0178b3340e4fc57f5187ddf55185156","modified":1574943553240},{"_id":"public/img/5945805.jpg","hash":"376e28d8461a6087c32927cdc937a98bec544604","modified":1574943553257},{"_id":"public/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1574943553257},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1574943553259},{"_id":"public/img/alipay.jpg","hash":"e457d1d3dfefbbd824d154cf756a2c6d10b812a2","modified":1574943553259},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1574943553259},{"_id":"public/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1574943553259},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1574943553259},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1574943553260},{"_id":"public/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1574943553260},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1574943553260},{"_id":"public/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1574943553260},{"_id":"public/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1574943553260},{"_id":"public/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1574943553260},{"_id":"public/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1574943553260},{"_id":"public/css/mobile.css","hash":"79ab291be160e0ca753512a96c5198f7477f13be","modified":1574943554688},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1574943554689},{"_id":"public/css/hl_theme/atom-light.css","hash":"a3c8f3ee9a655594eff7ac545cb2e6914c1abcc2","modified":1574943554689},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1574943554689},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1574943554689},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1574943554689},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1574943554690},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1574943554690},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1574943554690},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1574943554690},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1574943554690},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1574943554690},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1574943554690},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1574943554690},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1574943554690},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1574943554690},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1574943554691},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1574943554691},{"_id":"public/css/style.css","hash":"37e8c434cc17058a1a71a4e5bf0d655d519d6317","modified":1574943554691},{"_id":"public/img/weixin.jpg","hash":"8dafb22561698d0758fba9ea2a45abf6ad3512a2","modified":1574943554691},{"_id":"public/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1574943554692},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1574943554746},{"_id":"public/js/script.js","hash":"7502191e29366a11323dc72ae365b1aed254e6f2","modified":1574943554746},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1574943554746},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1574943554746},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1574943554772},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1574943554823},{"_id":"public/js/gitalk.js","hash":"d1eb82a3280981bd652d9a8e323060e4311c547b","modified":1574943554829}],"Category":[{"name":"JVM","_id":"ck3ioq5i80002lcvdbbmsr2z7"},{"name":"java基础","_id":"ck3ioq5iv000jlcvdwxuan41u"},{"name":"并发编程","_id":"ck3ioq5j7000qlcvdrmrwcopz"},{"name":"mybatis","_id":"ck3ioq5jd000wlcvdprka6rk4"},{"name":"mysql","_id":"ck3ioq5jn0017lcvd0mzujz6i"},{"name":"spring","_id":"ck3ioq5js001flcvdqabmdhjp"},{"name":"博客搭建","_id":"ck3ioq5kb0023lcvd9xjjru4d"},{"name":"容器","_id":"ck3ioq5kg002blcvdqfh8itni"},{"name":"缓存","_id":"ck3ioq5kn002klcvdrlghjhaz"},{"name":"网络","_id":"ck3ioq5kw002ulcvd3mnop2ly"},{"name":"面试","_id":"ck3ioq5l60036lcvd804jirxx"},{"name":"设计模式","_id":"ck3ioq5l9003clcvdhoocfjzm"}],"Data":[],"Page":[],"Post":[{"title":"JDK的命令行工具","_content":"\n# jinfo:查看已经运行的java进程信息\n* 查看最大堆内存：jinfo -flag MaxHeapSize 12036 \n>例：jinfo -flags 12036\n* 查看垃圾收集器：\n>jinfo -flag UseConcMarkSweepGC 12036\njinfo -flag UseG1GC 12036\njinfo -flag UseParallelGC 12036\n\n\n# jstat ：查看JVM统计信息\n* 类加载\n> jstat -class 12036\n* 垃圾收集\n> jstat -gc 12036\n* JIT编译\n>\n\n# jstack:打印JVM所有线程\n> jstack 12036","source":"_posts/JVM/JDK的命令行工具.md","raw":"---\ntitle: JDK的命令行工具\ntags: \n- JDK的命令行工具\ncategories:\n- JVM\n---\n\n# jinfo:查看已经运行的java进程信息\n* 查看最大堆内存：jinfo -flag MaxHeapSize 12036 \n>例：jinfo -flags 12036\n* 查看垃圾收集器：\n>jinfo -flag UseConcMarkSweepGC 12036\njinfo -flag UseG1GC 12036\njinfo -flag UseParallelGC 12036\n\n\n# jstat ：查看JVM统计信息\n* 类加载\n> jstat -class 12036\n* 垃圾收集\n> jstat -gc 12036\n* JIT编译\n>\n\n# jstack:打印JVM所有线程\n> jstack 12036","slug":"JVM/JDK的命令行工具","published":1,"date":"2019-10-30T13:01:32.638Z","updated":"2019-10-31T12:34:53.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5hy0000lcvdkie6j2ir","content":"<h1 id=\"jinfo-查看已经运行的java进程信息\"><a href=\"#jinfo-查看已经运行的java进程信息\" class=\"headerlink\" title=\"jinfo:查看已经运行的java进程信息\"></a>jinfo:查看已经运行的java进程信息</h1><ul>\n<li>查看最大堆内存：jinfo -flag MaxHeapSize 12036 <blockquote>\n<p>例：jinfo -flags 12036</p>\n</blockquote>\n</li>\n<li>查看垃圾收集器：<blockquote>\n<p>jinfo -flag UseConcMarkSweepGC 12036<br>jinfo -flag UseG1GC 12036<br>jinfo -flag UseParallelGC 12036</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"jstat-：查看JVM统计信息\"><a href=\"#jstat-：查看JVM统计信息\" class=\"headerlink\" title=\"jstat ：查看JVM统计信息\"></a>jstat ：查看JVM统计信息</h1><ul>\n<li>类加载<blockquote>\n<p>jstat -class 12036</p>\n</blockquote>\n</li>\n<li>垃圾收集<blockquote>\n<p>jstat -gc 12036</p>\n</blockquote>\n</li>\n<li>JIT编译<blockquote>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"jstack-打印JVM所有线程\"><a href=\"#jstack-打印JVM所有线程\" class=\"headerlink\" title=\"jstack:打印JVM所有线程\"></a>jstack:打印JVM所有线程</h1><blockquote>\n<p>jstack 12036</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jinfo-查看已经运行的java进程信息\"><a href=\"#jinfo-查看已经运行的java进程信息\" class=\"headerlink\" title=\"jinfo:查看已经运行的java进程信息\"></a>jinfo:查看已经运行的java进程信息</h1><ul>\n<li>查看最大堆内存：jinfo -flag MaxHeapSize 12036 <blockquote>\n<p>例：jinfo -flags 12036</p>\n</blockquote>\n</li>\n<li>查看垃圾收集器：<blockquote>\n<p>jinfo -flag UseConcMarkSweepGC 12036<br>jinfo -flag UseG1GC 12036<br>jinfo -flag UseParallelGC 12036</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"jstat-：查看JVM统计信息\"><a href=\"#jstat-：查看JVM统计信息\" class=\"headerlink\" title=\"jstat ：查看JVM统计信息\"></a>jstat ：查看JVM统计信息</h1><ul>\n<li>类加载<blockquote>\n<p>jstat -class 12036</p>\n</blockquote>\n</li>\n<li>垃圾收集<blockquote>\n<p>jstat -gc 12036</p>\n</blockquote>\n</li>\n<li>JIT编译<blockquote>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"jstack-打印JVM所有线程\"><a href=\"#jstack-打印JVM所有线程\" class=\"headerlink\" title=\"jstack:打印JVM所有线程\"></a>jstack:打印JVM所有线程</h1><blockquote>\n<p>jstack 12036</p>\n</blockquote>\n"},{"title":"JVM面试题","_content":"\n* 1.1.8为什么用Metaspace替换掉PermGen?Metaspace保存在哪里？\n* 2.编译器会对指令做哪些优化？（简单描述编译器的指令重拍）\n* 3.volatile可以解决什么问题？如何做到的？\n** 防止指令重排序\n** 强制从主内存中进行读写\n\n* 4.G1垃圾回收算法和CMS的区别有哪些？\n** G1不区分新生代，老年代，使用的是分区的模式","source":"_posts/JVM/JVM面试题.md","raw":"---\ntitle: JVM面试题\ntags: \n- 面试题\ncategories:\n- JVM\n---\n\n* 1.1.8为什么用Metaspace替换掉PermGen?Metaspace保存在哪里？\n* 2.编译器会对指令做哪些优化？（简单描述编译器的指令重拍）\n* 3.volatile可以解决什么问题？如何做到的？\n** 防止指令重排序\n** 强制从主内存中进行读写\n\n* 4.G1垃圾回收算法和CMS的区别有哪些？\n** G1不区分新生代，老年代，使用的是分区的模式","slug":"JVM/JVM面试题","published":1,"date":"2019-10-30T12:26:03.386Z","updated":"2019-10-30T12:36:16.008Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5i50001lcvdxwkr71gr","content":"<ul>\n<li><p>1.1.8为什么用Metaspace替换掉PermGen?Metaspace保存在哪里？</p>\n</li>\n<li><p>2.编译器会对指令做哪些优化？（简单描述编译器的指令重拍）</p>\n</li>\n<li><p>3.volatile可以解决什么问题？如何做到的？</p>\n</li>\n<li><ul>\n<li>防止指令重排序</li>\n</ul>\n</li>\n<li><ul>\n<li>强制从主内存中进行读写</li>\n</ul>\n</li>\n<li><p>4.G1垃圾回收算法和CMS的区别有哪些？</p>\n</li>\n<li><ul>\n<li>G1不区分新生代，老年代，使用的是分区的模式</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>1.1.8为什么用Metaspace替换掉PermGen?Metaspace保存在哪里？</p>\n</li>\n<li><p>2.编译器会对指令做哪些优化？（简单描述编译器的指令重拍）</p>\n</li>\n<li><p>3.volatile可以解决什么问题？如何做到的？</p>\n</li>\n<li><ul>\n<li>防止指令重排序</li>\n</ul>\n</li>\n<li><ul>\n<li>强制从主内存中进行读写</li>\n</ul>\n</li>\n<li><p>4.G1垃圾回收算法和CMS的区别有哪些？</p>\n</li>\n<li><ul>\n<li>G1不区分新生代，老年代，使用的是分区的模式</li>\n</ul>\n</li>\n</ul>\n"},{"title":"JVM参数","_content":"\n# X参数：非标准化参数\n* -Xint：解释执行\n* -Xcomp:第一次使用就编译成本地代码\n* -Xmixed：混合模式，JVM自己来决定是否编译成本地代码\n\n# 查看JVM运行时的参数\n* -XX:+PrintFlagsInitial\n> 例如：java -XX:+PrintFlagsFinal -version\n* -XX:+PrintFlagsFinal\n* -XX:+UnlockExperimentalVMOptions  ----解锁实验参数\n* -XX:+UnlockDiagnosticVMOptions  ----解锁诊断参数\n* -XX:+PrintCommandLineFlags  ----打印命令行参数","source":"_posts/JVM/JVM参数.md","raw":"---\ntitle: JVM参数\ntags: \n- JVM参数\ncategories:\n- JVM\n---\n\n# X参数：非标准化参数\n* -Xint：解释执行\n* -Xcomp:第一次使用就编译成本地代码\n* -Xmixed：混合模式，JVM自己来决定是否编译成本地代码\n\n# 查看JVM运行时的参数\n* -XX:+PrintFlagsInitial\n> 例如：java -XX:+PrintFlagsFinal -version\n* -XX:+PrintFlagsFinal\n* -XX:+UnlockExperimentalVMOptions  ----解锁实验参数\n* -XX:+UnlockDiagnosticVMOptions  ----解锁诊断参数\n* -XX:+PrintCommandLineFlags  ----打印命令行参数","slug":"JVM/JVM参数","published":1,"date":"2019-10-30T12:40:33.171Z","updated":"2019-10-30T13:17:36.139Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5ib0004lcvdown5xuvy","content":"<h1 id=\"X参数：非标准化参数\"><a href=\"#X参数：非标准化参数\" class=\"headerlink\" title=\"X参数：非标准化参数\"></a>X参数：非标准化参数</h1><ul>\n<li>-Xint：解释执行</li>\n<li>-Xcomp:第一次使用就编译成本地代码</li>\n<li>-Xmixed：混合模式，JVM自己来决定是否编译成本地代码</li>\n</ul>\n<h1 id=\"查看JVM运行时的参数\"><a href=\"#查看JVM运行时的参数\" class=\"headerlink\" title=\"查看JVM运行时的参数\"></a>查看JVM运行时的参数</h1><ul>\n<li>-XX:+PrintFlagsInitial<blockquote>\n<p>例如：java -XX:+PrintFlagsFinal -version</p>\n</blockquote>\n</li>\n<li>-XX:+PrintFlagsFinal</li>\n<li>-XX:+UnlockExperimentalVMOptions  —-解锁实验参数</li>\n<li>-XX:+UnlockDiagnosticVMOptions  —-解锁诊断参数</li>\n<li>-XX:+PrintCommandLineFlags  —-打印命令行参数</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"X参数：非标准化参数\"><a href=\"#X参数：非标准化参数\" class=\"headerlink\" title=\"X参数：非标准化参数\"></a>X参数：非标准化参数</h1><ul>\n<li>-Xint：解释执行</li>\n<li>-Xcomp:第一次使用就编译成本地代码</li>\n<li>-Xmixed：混合模式，JVM自己来决定是否编译成本地代码</li>\n</ul>\n<h1 id=\"查看JVM运行时的参数\"><a href=\"#查看JVM运行时的参数\" class=\"headerlink\" title=\"查看JVM运行时的参数\"></a>查看JVM运行时的参数</h1><ul>\n<li>-XX:+PrintFlagsInitial<blockquote>\n<p>例如：java -XX:+PrintFlagsFinal -version</p>\n</blockquote>\n</li>\n<li>-XX:+PrintFlagsFinal</li>\n<li>-XX:+UnlockExperimentalVMOptions  —-解锁实验参数</li>\n<li>-XX:+UnlockDiagnosticVMOptions  —-解锁诊断参数</li>\n<li>-XX:+PrintCommandLineFlags  —-打印命令行参数</li>\n</ul>\n"},{"title":"内存溢出","_content":"\n* Java中内存溢出和C++中内存溢出不太一样：\n> C++中的内存溢出是new出来的内存，指针丢了，不能被释放，Java中的内存溢出是内存一直被使用，不能被释放\n\n* 内存溢出自动导出：\n> 设置开启自动导出：  -XX:+HeapDumpOnOutOfMemoryError\n> 设置导出文件路径：  -XX:HeapDumpPath=./\n\n* 使用jmap命令手动导出\n\n* 使用jmap -heap [PID]打印java进程堆信息\n![alt jmap-heap](../assests/jmap-heap.png)","source":"_posts/JVM/内存溢出.md","raw":"---\ntitle: 内存溢出\ntags: \n- 内存溢出\ncategories:\n- JVM\n---\n\n* Java中内存溢出和C++中内存溢出不太一样：\n> C++中的内存溢出是new出来的内存，指针丢了，不能被释放，Java中的内存溢出是内存一直被使用，不能被释放\n\n* 内存溢出自动导出：\n> 设置开启自动导出：  -XX:+HeapDumpOnOutOfMemoryError\n> 设置导出文件路径：  -XX:HeapDumpPath=./\n\n* 使用jmap命令手动导出\n\n* 使用jmap -heap [PID]打印java进程堆信息\n![alt jmap-heap](../assests/jmap-heap.png)","slug":"JVM/内存溢出","published":1,"date":"2019-10-28T11:42:39.595Z","updated":"2019-11-04T12:17:45.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5id0005lcvdpg30kkrs","content":"<ul>\n<li><p>Java中内存溢出和C++中内存溢出不太一样：</p>\n<blockquote>\n<p>C++中的内存溢出是new出来的内存，指针丢了，不能被释放，Java中的内存溢出是内存一直被使用，不能被释放</p>\n</blockquote>\n</li>\n<li><p>内存溢出自动导出：</p>\n<blockquote>\n<p>设置开启自动导出：  -XX:+HeapDumpOnOutOfMemoryError<br>设置导出文件路径：  -XX:HeapDumpPath=./</p>\n</blockquote>\n</li>\n<li><p>使用jmap命令手动导出</p>\n</li>\n<li><p>使用jmap -heap [PID]打印java进程堆信息<br><img src=\"../assests/jmap-heap.png\" alt=\"alt jmap-heap\"></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>Java中内存溢出和C++中内存溢出不太一样：</p>\n<blockquote>\n<p>C++中的内存溢出是new出来的内存，指针丢了，不能被释放，Java中的内存溢出是内存一直被使用，不能被释放</p>\n</blockquote>\n</li>\n<li><p>内存溢出自动导出：</p>\n<blockquote>\n<p>设置开启自动导出：  -XX:+HeapDumpOnOutOfMemoryError<br>设置导出文件路径：  -XX:HeapDumpPath=./</p>\n</blockquote>\n</li>\n<li><p>使用jmap命令手动导出</p>\n</li>\n<li><p>使用jmap -heap [PID]打印java进程堆信息<br><img src=\"../assests/jmap-heap.png\" alt=\"alt jmap-heap\"></p>\n</li>\n</ul>\n"},{"_content":"# 1、系统相关\n\n## 1、uname -r\n\n查看内核版本\n\n## 2、yum update\n\n升级内核\n\n","source":"_posts/linux/命令.md","raw":"# 1、系统相关\n\n## 1、uname -r\n\n查看内核版本\n\n## 2、yum update\n\n升级内核\n\n","slug":"linux/命令","published":1,"date":"2019-11-13T14:07:11.573Z","updated":"2019-11-13T14:07:11.574Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5ie0006lcvdu0rb31kr","content":"<h1 id=\"1、系统相关\"><a href=\"#1、系统相关\" class=\"headerlink\" title=\"1、系统相关\"></a>1、系统相关</h1><h2 id=\"1、uname-r\"><a href=\"#1、uname-r\" class=\"headerlink\" title=\"1、uname -r\"></a>1、uname -r</h2><p>查看内核版本</p>\n<h2 id=\"2、yum-update\"><a href=\"#2、yum-update\" class=\"headerlink\" title=\"2、yum update\"></a>2、yum update</h2><p>升级内核</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1、系统相关\"><a href=\"#1、系统相关\" class=\"headerlink\" title=\"1、系统相关\"></a>1、系统相关</h1><h2 id=\"1、uname-r\"><a href=\"#1、uname-r\" class=\"headerlink\" title=\"1、uname -r\"></a>1、uname -r</h2><p>查看内核版本</p>\n<h2 id=\"2、yum-update\"><a href=\"#2、yum-update\" class=\"headerlink\" title=\"2、yum update\"></a>2、yum update</h2><p>升级内核</p>\n"},{"title":"static关键字","date":"2019-09-11T16:00:00.000Z","_content":"\n# static\n* 1.修饰成员变量\n* 2.修饰成员方法\n* 3.修饰代码块\n* 4.修饰内部类\n* 5.静态导入","source":"_posts/javabase/static.md","raw":"---\ntitle: static关键字\ndate: 2019-9-12\ntags: \n- java基础\ncategories:\n- java基础\n---\n\n# static\n* 1.修饰成员变量\n* 2.修饰成员方法\n* 3.修饰代码块\n* 4.修饰内部类\n* 5.静态导入","slug":"javabase/static","published":1,"updated":"2019-09-13T01:40:53.672Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5ij000alcvdaw0jlxhz","content":"<h1 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h1><ul>\n<li>1.修饰成员变量</li>\n<li>2.修饰成员方法</li>\n<li>3.修饰代码块</li>\n<li>4.修饰内部类</li>\n<li>5.静态导入</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"static\"><a href=\"#static\" class=\"headerlink\" title=\"static\"></a>static</h1><ul>\n<li>1.修饰成员变量</li>\n<li>2.修饰成员方法</li>\n<li>3.修饰代码块</li>\n<li>4.修饰内部类</li>\n<li>5.静态导入</li>\n</ul>\n"},{"title":"线程的生命周期","_content":"\n待编写","source":"_posts/multiThread/threadLifeCycle.md","raw":"---\ntitle: 线程的生命周期\ntags: \n- 线程\ncategories:\n- 并发编程\n---\n\n待编写","slug":"multiThread/threadLifeCycle","published":1,"date":"2019-09-12T13:26:46.270Z","updated":"2019-09-12T14:22:10.370Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5in000blcvdvsny1zhs","content":"<p>待编写</p>\n","site":{"data":{}},"excerpt":"","more":"<p>待编写</p>\n"},{"title":"binding模块","_content":"\n\n","source":"_posts/mybatis/binding模块.md","raw":"---\ntitle: binding模块\ntags: \n- mybatis\ncategories:\n- mybatis\n---\n\n\n","slug":"mybatis/binding模块","published":1,"date":"2019-09-18T13:57:30.431Z","updated":"2019-09-18T13:58:57.703Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5iq000flcvdd2fx4k8g","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"异常","_content":"\n\n# try-catch性能消耗的地方\n* try-catch块影响JVM优化\n* 异常对象实例需要保存栈快照等信息，开销较大","source":"_posts/javabase/异常.md","raw":"---\ntitle: 异常\ntags: \n- 异常\ncategories:\n- java基础\n---\n\n\n# try-catch性能消耗的地方\n* try-catch块影响JVM优化\n* 异常对象实例需要保存栈快照等信息，开销较大","slug":"javabase/异常","published":1,"date":"2019-10-11T12:32:22.550Z","updated":"2019-10-11T12:34:15.173Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5is000ilcvdbm05o8hz","content":"<h1 id=\"try-catch性能消耗的地方\"><a href=\"#try-catch性能消耗的地方\" class=\"headerlink\" title=\"try-catch性能消耗的地方\"></a>try-catch性能消耗的地方</h1><ul>\n<li>try-catch块影响JVM优化</li>\n<li>异常对象实例需要保存栈快照等信息，开销较大</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"try-catch性能消耗的地方\"><a href=\"#try-catch性能消耗的地方\" class=\"headerlink\" title=\"try-catch性能消耗的地方\"></a>try-catch性能消耗的地方</h1><ul>\n<li>try-catch块影响JVM优化</li>\n<li>异常对象实例需要保存栈快照等信息，开销较大</li>\n</ul>\n"},{"_content":"# Springboot优点\n\n1.快速穿件独立运行的Spring项目以及与主流框架集成\n\n2.使用嵌入式的Servlet容器，应用无需打成WAR包\n\n3.starters自动依赖与版本控制\n\n4.大量的自动配置，简化开发，也可修改默认值\n\n5.无需配置XML,无代码生成，开箱即用\n\n6.准生产环境的运行时应用监控\n\n5.与云计算的天然集成","source":"_posts/springboot/Springboot优点.md","raw":"# Springboot优点\n\n1.快速穿件独立运行的Spring项目以及与主流框架集成\n\n2.使用嵌入式的Servlet容器，应用无需打成WAR包\n\n3.starters自动依赖与版本控制\n\n4.大量的自动配置，简化开发，也可修改默认值\n\n5.无需配置XML,无代码生成，开箱即用\n\n6.准生产环境的运行时应用监控\n\n5.与云计算的天然集成","slug":"springboot/Springboot优点","published":1,"date":"2019-11-10T05:22:06.579Z","updated":"2019-11-10T05:22:06.580Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5iy000mlcvdcgv4s8ul","content":"<h1 id=\"Springboot优点\"><a href=\"#Springboot优点\" class=\"headerlink\" title=\"Springboot优点\"></a>Springboot优点</h1><p>1.快速穿件独立运行的Spring项目以及与主流框架集成</p>\n<p>2.使用嵌入式的Servlet容器，应用无需打成WAR包</p>\n<p>3.starters自动依赖与版本控制</p>\n<p>4.大量的自动配置，简化开发，也可修改默认值</p>\n<p>5.无需配置XML,无代码生成，开箱即用</p>\n<p>6.准生产环境的运行时应用监控</p>\n<p>5.与云计算的天然集成</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Springboot优点\"><a href=\"#Springboot优点\" class=\"headerlink\" title=\"Springboot优点\"></a>Springboot优点</h1><p>1.快速穿件独立运行的Spring项目以及与主流框架集成</p>\n<p>2.使用嵌入式的Servlet容器，应用无需打成WAR包</p>\n<p>3.starters自动依赖与版本控制</p>\n<p>4.大量的自动配置，简化开发，也可修改默认值</p>\n<p>5.无需配置XML,无代码生成，开箱即用</p>\n<p>6.准生产环境的运行时应用监控</p>\n<p>5.与云计算的天然集成</p>\n"},{"title":"mysql","_content":"\n","source":"_posts/mysql/index.md","raw":"---\ntitle: mysql\ntags: \n- mysql\ncategories:\n- mysql\n---\n\n","slug":"mysql/index","published":1,"date":"2019-09-12T13:26:46.278Z","updated":"2019-10-11T12:34:55.043Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5j3000olcvdzpuox7jf","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"# 自定义starter\n\nstarter：\n\n​\t1、这个场景需要使用到的依赖是什么？\n\n​\t2、如何编写自动配置\n\n```java\n@Configuration //指定这个类是一个配置类\n@ConfigurationOnXXX //在指定条件成立的情况下自动配置类生效\n@AutoConfigureAfter  //指定自动配置类的顺序\n@Bean  //给容器中添加组件\n\n@ConditionalOnProperty //结合相关xxxProperties类来绑定相关的配置\n@EnableConfigurationProperties //让xxxProperties生效加入到容器中\n\n自动配置类要能加载：将需要启动就加载的自动配置类，配置在META-INF/spring.factories\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\n```\n\n​\t3、模式\n\n​\t启动器只用来做依赖导入；\n\n​\t专门来写一个自动配置模块；\n\n​\t启动器依赖自动配置；别人只需要引入启动器（starter）","source":"_posts/springboot/自定义starter.md","raw":"# 自定义starter\n\nstarter：\n\n​\t1、这个场景需要使用到的依赖是什么？\n\n​\t2、如何编写自动配置\n\n```java\n@Configuration //指定这个类是一个配置类\n@ConfigurationOnXXX //在指定条件成立的情况下自动配置类生效\n@AutoConfigureAfter  //指定自动配置类的顺序\n@Bean  //给容器中添加组件\n\n@ConditionalOnProperty //结合相关xxxProperties类来绑定相关的配置\n@EnableConfigurationProperties //让xxxProperties生效加入到容器中\n\n自动配置类要能加载：将需要启动就加载的自动配置类，配置在META-INF/spring.factories\n# Auto Configure\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\\norg.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\\norg.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\\norg.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\\n```\n\n​\t3、模式\n\n​\t启动器只用来做依赖导入；\n\n​\t专门来写一个自动配置模块；\n\n​\t启动器依赖自动配置；别人只需要引入启动器（starter）","slug":"springboot/自定义starter","published":1,"date":"2019-11-09T02:24:28.568Z","updated":"2019-11-09T04:49:39.038Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5j9000slcvdjs0fwd8j","content":"<h1 id=\"自定义starter\"><a href=\"#自定义starter\" class=\"headerlink\" title=\"自定义starter\"></a>自定义starter</h1><p>starter：</p>\n<p>​    1、这个场景需要使用到的依赖是什么？</p>\n<p>​    2、如何编写自动配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span> <span class=\"comment\">//指定这个类是一个配置类</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationOnXXX</span> <span class=\"comment\">//在指定条件成立的情况下自动配置类生效</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureAfter</span>  <span class=\"comment\">//指定自动配置类的顺序</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span>  <span class=\"comment\">//给容器中添加组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnProperty</span> <span class=\"comment\">//结合相关xxxProperties类来绑定相关的配置</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties</span> <span class=\"comment\">//让xxxProperties生效加入到容器中</span></span><br><span class=\"line\"></span><br><span class=\"line\">自动配置类要能加载：将需要启动就加载的自动配置类，配置在META-INF/spring.factories</span><br><span class=\"line\"># Auto Configure</span><br><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</span><br></pre></td></tr></table></figure>\n\n<p>​    3、模式</p>\n<p>​    启动器只用来做依赖导入；</p>\n<p>​    专门来写一个自动配置模块；</p>\n<p>​    启动器依赖自动配置；别人只需要引入启动器（starter）</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"自定义starter\"><a href=\"#自定义starter\" class=\"headerlink\" title=\"自定义starter\"></a>自定义starter</h1><p>starter：</p>\n<p>​    1、这个场景需要使用到的依赖是什么？</p>\n<p>​    2、如何编写自动配置</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Configuration</span> <span class=\"comment\">//指定这个类是一个配置类</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationOnXXX</span> <span class=\"comment\">//在指定条件成立的情况下自动配置类生效</span></span><br><span class=\"line\"><span class=\"meta\">@AutoConfigureAfter</span>  <span class=\"comment\">//指定自动配置类的顺序</span></span><br><span class=\"line\"><span class=\"meta\">@Bean</span>  <span class=\"comment\">//给容器中添加组件</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@ConditionalOnProperty</span> <span class=\"comment\">//结合相关xxxProperties类来绑定相关的配置</span></span><br><span class=\"line\"><span class=\"meta\">@EnableConfigurationProperties</span> <span class=\"comment\">//让xxxProperties生效加入到容器中</span></span><br><span class=\"line\"></span><br><span class=\"line\">自动配置类要能加载：将需要启动就加载的自动配置类，配置在META-INF/spring.factories</span><br><span class=\"line\"># Auto Configure</span><br><span class=\"line\">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\</span><br><span class=\"line\">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\</span><br></pre></td></tr></table></figure>\n\n<p>​    3、模式</p>\n<p>​    启动器只用来做依赖导入；</p>\n<p>​    专门来写一个自动配置模块；</p>\n<p>​    启动器依赖自动配置；别人只需要引入启动器（starter）</p>\n"},{"title":"spring mvc","_content":"\n* MVC模型：\n> M:模型层，负责数据模型的抽取\n  V:视图层，负责数据的展示\n  C:控制层，负责请求的分发控制","source":"_posts/spring/SpringMVC.md","raw":"---\ntitle: spring mvc\ntags: \n- spring\ncategories:\n- spring\n---\n\n* MVC模型：\n> M:模型层，负责数据模型的抽取\n  V:视图层，负责数据的展示\n  C:控制层，负责请求的分发控制","slug":"spring/SpringMVC","published":1,"date":"2019-10-31T12:35:33.558Z","updated":"2019-10-31T12:38:17.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5jb000ulcvdbgb0uoei","content":"<ul>\n<li>MVC模型：<blockquote>\n<p>M:模型层，负责数据模型的抽取<br>V:视图层，负责数据的展示<br>C:控制层，负责请求的分发控制</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li>MVC模型：<blockquote>\n<p>M:模型层，负责数据模型的抽取<br>V:视图层，负责数据的展示<br>C:控制层，负责请求的分发控制</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"spring中的设计模式","_content":"\nAOP调用:责任链模式","source":"_posts/spring/spring中的设计模式.md","raw":"---\ntitle: spring中的设计模式\ntags: \n- spring\n- 设计模式\ncategories:\n- spring\n---\n\nAOP调用:责任链模式","slug":"spring/spring中的设计模式","published":1,"date":"2019-09-12T13:26:46.296Z","updated":"2019-09-14T23:33:23.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5je000xlcvd2alan9i1","content":"<p>AOP调用:责任链模式</p>\n","site":{"data":{}},"excerpt":"","more":"<p>AOP调用:责任链模式</p>\n"},{"title":"spring组件","_content":"\nBeanFactoryPostProcessor：beanFactory的后置处理器\nBeanDefinitionRegistryPostProcessor:bean定义后置处理器","source":"_posts/spring/Spring组件.md","raw":"---\ntitle: spring组件\ntags: \n- spring\ncategories:\n- spring\n---\n\nBeanFactoryPostProcessor：beanFactory的后置处理器\nBeanDefinitionRegistryPostProcessor:bean定义后置处理器","slug":"spring/Spring组件","published":1,"date":"2019-09-12T13:26:46.299Z","updated":"2019-09-13T01:37:29.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5jg0010lcvd5z0e62uz","content":"<p>BeanFactoryPostProcessor：beanFactory的后置处理器<br>BeanDefinitionRegistryPostProcessor:bean定义后置处理器</p>\n","site":{"data":{}},"excerpt":"","more":"<p>BeanFactoryPostProcessor：beanFactory的后置处理器<br>BeanDefinitionRegistryPostProcessor:bean定义后置处理器</p>\n"},{"title":"AOP底层源码","_content":"\n\n# AOP调用过程：\n* 配置类上加@EnableAspectJAutoProxy注解\n* @EnableAspectJAutoProxy注解使用了@Import(AspectJAutoProxyRegistrar.class)\n* AspectJAutoProxyRegistrar类调用registerBeanDefinitions方法\n* registerBeanDefinitions方法中调用AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry) \n* registerAspectJAnnotationAutoProxyCreatorIfNecessary中向容器注册名为key为**org.springframework.aop.config.internalAutoProxyCreator**，value是**AnnotationAwareAspectJAutoProxyCreator*，这个类是BeanPostProcessor的子类\n* AnnotationAwareAspectJAutoProxyCreator：贯穿了AOP,继承关系如下：\n* AnnotationAwareAspectJAutoProxyCreator\n\t* AspectJAwareAdvisorAutoProxyCreator\n\t\t* AbstractAdvisorAutoProxyCreator\n\t\t\t* AbstractAutoProxyCreator  extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware\n\t\t\t* 关注后置处理器，自动装配BeanFactory\n* SmartInstantiationAwareBeanPostProcessor:bean的后置处理器\n* BeanFactoryAware：能把beanFactory传进来\n\n***\n# IOC创建internalAutoProxyCreator的bean，调用过程：\n* refresh()\n\t* registerBeanPostProcessors(beanFactory);\n\t\t* PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);\n\t\t\t* AnnotationAwareAspectJAutoProxyCreator实现了Ordered接口，执行对应逻辑\n\t\t\t\t*  进入beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\t\t\t*  doGetBean(name, requiredType, null, false);\n\t\t\t\t\t\t* createBean\n\t\t\t\t\t\t\t* Object bean = resolveBeforeInstantiation(beanName, mbdToUse);  返回代理对象，会有前置通知后置通知\n\t\t\t\t\t\t\t\t* bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n\t\t\t\t\t\t\t\t\t* \tObject result = ibp.postProcessBeforeInstantiation(beanClass, beanName); \n\t\t\t\t\t\t\t\t\t\t* Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); 产生代理对象\n\t\t\t\t\t\t\t\t\t\t\t*  proxyFactory.getProxy(getProxyClassLoader()); \n\t\t\t\t\t\t\t\t\t\t\t\t* return createAopProxy().getProxy(classLoader);   `proxyFactory有cglib和jdk两种实现`\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t* Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n\t\t\t\t\t\t\t\t\t* \tinstanceWrapper = createBeanInstance(beanName, mbd, args);\n\n***\n# AnnotationAwareAspectJAutoProxyCreator利用后置处理器的方法拦截代理方法\n* refresh()\n\t* finishBeanFactoryInitialization(beanFactory);\n\t\t* beanFactory.preInstantiateSingletons();\n\t\t\t* \tgetBean(beanName);\n\t\t\t\t* doGetBean\n\t\t\t\t\t* createBean\n\t\t\t\t\t\t* Object bean = resolveBeforeInstantiation(beanName, mbdToUse); ：返回被代理类\n\t\t\t\t\t\t\t* applyBeanPostProcessorsAfterInitialization  ：后置处理器，对bean进行增强\n\t\t\t\t\t\t\t\t* beanProcessor.postProcessAfterInitialization(result, beanName);\n\t\t\t\t\t\t\t\t\t* wrapIfNecessary\n\t\t\t\t\t\t\t\t\t\t* getAdvicesAndAdvisorsForBean 获取通知\n\t\t\t\t\t\t\t\t\t\t* createProxy：代理工厂创建代理类\n***\n# AOP调用过程：\n1. 获取拦截链\n2. 链式调用通知方法\n* CglibAopProxy.DynamicAdvisedInterceptor内部类的intercept\n\t* getInterceptorsAndDynamicInterceptionAdvice\n\t\t*  this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\t\t\tthis, method, targetClass);\n* retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();\n\n\n# AOP过程猜想：\n* 1.拦截方法\n* 2.调用IOC的createBean()方法\n* 3.","source":"_posts/spring/AOP底层源码.md","raw":"---\ntitle: AOP底层源码\ntags: \n- AOP\ncategories:\n- spring\n---\n\n\n# AOP调用过程：\n* 配置类上加@EnableAspectJAutoProxy注解\n* @EnableAspectJAutoProxy注解使用了@Import(AspectJAutoProxyRegistrar.class)\n* AspectJAutoProxyRegistrar类调用registerBeanDefinitions方法\n* registerBeanDefinitions方法中调用AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry) \n* registerAspectJAnnotationAutoProxyCreatorIfNecessary中向容器注册名为key为**org.springframework.aop.config.internalAutoProxyCreator**，value是**AnnotationAwareAspectJAutoProxyCreator*，这个类是BeanPostProcessor的子类\n* AnnotationAwareAspectJAutoProxyCreator：贯穿了AOP,继承关系如下：\n* AnnotationAwareAspectJAutoProxyCreator\n\t* AspectJAwareAdvisorAutoProxyCreator\n\t\t* AbstractAdvisorAutoProxyCreator\n\t\t\t* AbstractAutoProxyCreator  extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware\n\t\t\t* 关注后置处理器，自动装配BeanFactory\n* SmartInstantiationAwareBeanPostProcessor:bean的后置处理器\n* BeanFactoryAware：能把beanFactory传进来\n\n***\n# IOC创建internalAutoProxyCreator的bean，调用过程：\n* refresh()\n\t* registerBeanPostProcessors(beanFactory);\n\t\t* PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);\n\t\t\t* AnnotationAwareAspectJAutoProxyCreator实现了Ordered接口，执行对应逻辑\n\t\t\t\t*  进入beanFactory.getBean(ppName, BeanPostProcessor.class);\n\t\t\t\t\t*  doGetBean(name, requiredType, null, false);\n\t\t\t\t\t\t* createBean\n\t\t\t\t\t\t\t* Object bean = resolveBeforeInstantiation(beanName, mbdToUse);  返回代理对象，会有前置通知后置通知\n\t\t\t\t\t\t\t\t* bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);\n\t\t\t\t\t\t\t\t\t* \tObject result = ibp.postProcessBeforeInstantiation(beanClass, beanName); \n\t\t\t\t\t\t\t\t\t\t* Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); 产生代理对象\n\t\t\t\t\t\t\t\t\t\t\t*  proxyFactory.getProxy(getProxyClassLoader()); \n\t\t\t\t\t\t\t\t\t\t\t\t* return createAopProxy().getProxy(classLoader);   `proxyFactory有cglib和jdk两种实现`\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t* Object beanInstance = doCreateBean(beanName, mbdToUse, args);\n\t\t\t\t\t\t\t\t\t* \tinstanceWrapper = createBeanInstance(beanName, mbd, args);\n\n***\n# AnnotationAwareAspectJAutoProxyCreator利用后置处理器的方法拦截代理方法\n* refresh()\n\t* finishBeanFactoryInitialization(beanFactory);\n\t\t* beanFactory.preInstantiateSingletons();\n\t\t\t* \tgetBean(beanName);\n\t\t\t\t* doGetBean\n\t\t\t\t\t* createBean\n\t\t\t\t\t\t* Object bean = resolveBeforeInstantiation(beanName, mbdToUse); ：返回被代理类\n\t\t\t\t\t\t\t* applyBeanPostProcessorsAfterInitialization  ：后置处理器，对bean进行增强\n\t\t\t\t\t\t\t\t* beanProcessor.postProcessAfterInitialization(result, beanName);\n\t\t\t\t\t\t\t\t\t* wrapIfNecessary\n\t\t\t\t\t\t\t\t\t\t* getAdvicesAndAdvisorsForBean 获取通知\n\t\t\t\t\t\t\t\t\t\t* createProxy：代理工厂创建代理类\n***\n# AOP调用过程：\n1. 获取拦截链\n2. 链式调用通知方法\n* CglibAopProxy.DynamicAdvisedInterceptor内部类的intercept\n\t* getInterceptorsAndDynamicInterceptionAdvice\n\t\t*  this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(\n\t\t\t\t\tthis, method, targetClass);\n* retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();\n\n\n# AOP过程猜想：\n* 1.拦截方法\n* 2.调用IOC的createBean()方法\n* 3.","slug":"spring/AOP底层源码","published":1,"date":"2019-09-12T13:26:46.293Z","updated":"2019-09-14T23:33:40.162Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5ji0013lcvd7h1c2b5q","content":"<h1 id=\"AOP调用过程：\"><a href=\"#AOP调用过程：\" class=\"headerlink\" title=\"AOP调用过程：\"></a>AOP调用过程：</h1><ul>\n<li>配置类上加@EnableAspectJAutoProxy注解</li>\n<li>@EnableAspectJAutoProxy注解使用了@Import(AspectJAutoProxyRegistrar.class)</li>\n<li>AspectJAutoProxyRegistrar类调用registerBeanDefinitions方法</li>\n<li>registerBeanDefinitions方法中调用AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry) </li>\n<li>registerAspectJAnnotationAutoProxyCreatorIfNecessary中向容器注册名为key为<strong>org.springframework.aop.config.internalAutoProxyCreator</strong>，value是*<em>AnnotationAwareAspectJAutoProxyCreator</em>，这个类是BeanPostProcessor的子类</li>\n<li>AnnotationAwareAspectJAutoProxyCreator：贯穿了AOP,继承关系如下：</li>\n<li>AnnotationAwareAspectJAutoProxyCreator<ul>\n<li>AspectJAwareAdvisorAutoProxyCreator<ul>\n<li>AbstractAdvisorAutoProxyCreator<ul>\n<li>AbstractAutoProxyCreator  extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</li>\n<li>关注后置处理器，自动装配BeanFactory</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>SmartInstantiationAwareBeanPostProcessor:bean的后置处理器</li>\n<li>BeanFactoryAware：能把beanFactory传进来</li>\n</ul>\n<hr>\n<h1 id=\"IOC创建internalAutoProxyCreator的bean，调用过程：\"><a href=\"#IOC创建internalAutoProxyCreator的bean，调用过程：\" class=\"headerlink\" title=\"IOC创建internalAutoProxyCreator的bean，调用过程：\"></a>IOC创建internalAutoProxyCreator的bean，调用过程：</h1><ul>\n<li><p>refresh()</p>\n<ul>\n<li><p>registerBeanPostProcessors(beanFactory);</p>\n<ul>\n<li><p>PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);</p>\n<ul>\n<li><p>AnnotationAwareAspectJAutoProxyCreator实现了Ordered接口，执行对应逻辑</p>\n<ul>\n<li><p>进入beanFactory.getBean(ppName, BeanPostProcessor.class);</p>\n<ul>\n<li><p>doGetBean(name, requiredType, null, false);</p>\n<ul>\n<li><p>createBean</p>\n<ul>\n<li><p>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);  返回代理对象，会有前置通知后置通知</p>\n<ul>\n<li><p>bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</p>\n<ul>\n<li>Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName); <ul>\n<li>Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); 产生代理对象<ul>\n<li>proxyFactory.getProxy(getProxyClassLoader()); <ul>\n<li>return createAopProxy().getProxy(classLoader);   <code>proxyFactory有cglib和jdk两种实现</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</p>\n<ul>\n<li>instanceWrapper = createBeanInstance(beanName, mbd, args);</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"AnnotationAwareAspectJAutoProxyCreator利用后置处理器的方法拦截代理方法\"><a href=\"#AnnotationAwareAspectJAutoProxyCreator利用后置处理器的方法拦截代理方法\" class=\"headerlink\" title=\"AnnotationAwareAspectJAutoProxyCreator利用后置处理器的方法拦截代理方法\"></a>AnnotationAwareAspectJAutoProxyCreator利用后置处理器的方法拦截代理方法</h1><ul>\n<li>refresh()<ul>\n<li>finishBeanFactoryInitialization(beanFactory);<ul>\n<li>beanFactory.preInstantiateSingletons();<ul>\n<li>getBean(beanName);<ul>\n<li>doGetBean<ul>\n<li>createBean<ul>\n<li>Object bean = resolveBeforeInstantiation(beanName, mbdToUse); ：返回被代理类<ul>\n<li>applyBeanPostProcessorsAfterInitialization  ：后置处理器，对bean进行增强<ul>\n<li>beanProcessor.postProcessAfterInitialization(result, beanName);<ul>\n<li>wrapIfNecessary<ul>\n<li>getAdvicesAndAdvisorsForBean 获取通知</li>\n<li>createProxy：代理工厂创建代理类</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"AOP调用过程：-1\"><a href=\"#AOP调用过程：-1\" class=\"headerlink\" title=\"AOP调用过程：\"></a>AOP调用过程：</h1><ol>\n<li>获取拦截链</li>\n<li>链式调用通知方法</li>\n</ol>\n<ul>\n<li>CglibAopProxy.DynamicAdvisedInterceptor内部类的intercept<ul>\n<li>getInterceptorsAndDynamicInterceptionAdvice<ul>\n<li>this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(<pre><code>this, method, targetClass);</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</li>\n</ul>\n<h1 id=\"AOP过程猜想：\"><a href=\"#AOP过程猜想：\" class=\"headerlink\" title=\"AOP过程猜想：\"></a>AOP过程猜想：</h1><ul>\n<li>1.拦截方法</li>\n<li>2.调用IOC的createBean()方法</li>\n<li>3.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AOP调用过程：\"><a href=\"#AOP调用过程：\" class=\"headerlink\" title=\"AOP调用过程：\"></a>AOP调用过程：</h1><ul>\n<li>配置类上加@EnableAspectJAutoProxy注解</li>\n<li>@EnableAspectJAutoProxy注解使用了@Import(AspectJAutoProxyRegistrar.class)</li>\n<li>AspectJAutoProxyRegistrar类调用registerBeanDefinitions方法</li>\n<li>registerBeanDefinitions方法中调用AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry) </li>\n<li>registerAspectJAnnotationAutoProxyCreatorIfNecessary中向容器注册名为key为<strong>org.springframework.aop.config.internalAutoProxyCreator</strong>，value是*<em>AnnotationAwareAspectJAutoProxyCreator</em>，这个类是BeanPostProcessor的子类</li>\n<li>AnnotationAwareAspectJAutoProxyCreator：贯穿了AOP,继承关系如下：</li>\n<li>AnnotationAwareAspectJAutoProxyCreator<ul>\n<li>AspectJAwareAdvisorAutoProxyCreator<ul>\n<li>AbstractAdvisorAutoProxyCreator<ul>\n<li>AbstractAutoProxyCreator  extends ProxyProcessorSupport implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware</li>\n<li>关注后置处理器，自动装配BeanFactory</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>SmartInstantiationAwareBeanPostProcessor:bean的后置处理器</li>\n<li>BeanFactoryAware：能把beanFactory传进来</li>\n</ul>\n<hr>\n<h1 id=\"IOC创建internalAutoProxyCreator的bean，调用过程：\"><a href=\"#IOC创建internalAutoProxyCreator的bean，调用过程：\" class=\"headerlink\" title=\"IOC创建internalAutoProxyCreator的bean，调用过程：\"></a>IOC创建internalAutoProxyCreator的bean，调用过程：</h1><ul>\n<li><p>refresh()</p>\n<ul>\n<li><p>registerBeanPostProcessors(beanFactory);</p>\n<ul>\n<li><p>PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);</p>\n<ul>\n<li><p>AnnotationAwareAspectJAutoProxyCreator实现了Ordered接口，执行对应逻辑</p>\n<ul>\n<li><p>进入beanFactory.getBean(ppName, BeanPostProcessor.class);</p>\n<ul>\n<li><p>doGetBean(name, requiredType, null, false);</p>\n<ul>\n<li><p>createBean</p>\n<ul>\n<li><p>Object bean = resolveBeforeInstantiation(beanName, mbdToUse);  返回代理对象，会有前置通知后置通知</p>\n<ul>\n<li><p>bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</p>\n<ul>\n<li>Object result = ibp.postProcessBeforeInstantiation(beanClass, beanName); <ul>\n<li>Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource); 产生代理对象<ul>\n<li>proxyFactory.getProxy(getProxyClassLoader()); <ul>\n<li>return createAopProxy().getProxy(classLoader);   <code>proxyFactory有cglib和jdk两种实现</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>Object beanInstance = doCreateBean(beanName, mbdToUse, args);</p>\n<ul>\n<li>instanceWrapper = createBeanInstance(beanName, mbd, args);</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"AnnotationAwareAspectJAutoProxyCreator利用后置处理器的方法拦截代理方法\"><a href=\"#AnnotationAwareAspectJAutoProxyCreator利用后置处理器的方法拦截代理方法\" class=\"headerlink\" title=\"AnnotationAwareAspectJAutoProxyCreator利用后置处理器的方法拦截代理方法\"></a>AnnotationAwareAspectJAutoProxyCreator利用后置处理器的方法拦截代理方法</h1><ul>\n<li>refresh()<ul>\n<li>finishBeanFactoryInitialization(beanFactory);<ul>\n<li>beanFactory.preInstantiateSingletons();<ul>\n<li>getBean(beanName);<ul>\n<li>doGetBean<ul>\n<li>createBean<ul>\n<li>Object bean = resolveBeforeInstantiation(beanName, mbdToUse); ：返回被代理类<ul>\n<li>applyBeanPostProcessorsAfterInitialization  ：后置处理器，对bean进行增强<ul>\n<li>beanProcessor.postProcessAfterInitialization(result, beanName);<ul>\n<li>wrapIfNecessary<ul>\n<li>getAdvicesAndAdvisorsForBean 获取通知</li>\n<li>createProxy：代理工厂创建代理类</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<hr>\n<h1 id=\"AOP调用过程：-1\"><a href=\"#AOP调用过程：-1\" class=\"headerlink\" title=\"AOP调用过程：\"></a>AOP调用过程：</h1><ol>\n<li>获取拦截链</li>\n<li>链式调用通知方法</li>\n</ol>\n<ul>\n<li>CglibAopProxy.DynamicAdvisedInterceptor内部类的intercept<ul>\n<li>getInterceptorsAndDynamicInterceptionAdvice<ul>\n<li>this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(<pre><code>this, method, targetClass);</code></pre></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();</li>\n</ul>\n<h1 id=\"AOP过程猜想：\"><a href=\"#AOP过程猜想：\" class=\"headerlink\" title=\"AOP过程猜想：\"></a>AOP过程猜想：</h1><ul>\n<li>1.拦截方法</li>\n<li>2.调用IOC的createBean()方法</li>\n<li>3.</li>\n</ul>\n"},{"_content":"# 一、面试题\n\n##1.什么是微服务？\n\n```\n\n```\n\n\n\n##2.微服务之间是如何独立通讯的？\n\n```\n\n```\n\n\n\n##3.springcloud和dubbo有哪些区别？\n\n```\ndubbo：基于RPC,SpringCloud:基于Restful API\n```\n\n|        | Dubbo     | Spring Cloud |\n| ------ | --------- | ------------ |\n| 服务注册中心 | zookeeper | eureka       |\n| 服务调用方式 | RPC       | RestAPI      |\n| 服务监控   | monitor   | Admin        |\n| 断路器    | 不完善       | Hystrix      |\n| 服务网关   | 无         | Zuul         |\n| 分布式配置  | 无         | Config       |\n| 服务跟踪   | 无         | Sleuth       |\n| 消息总线   | 无         | Bus          |\n| 数据流    | 无         | Stream       |\n| 批量任务   | 无         | Task         |\n\n\n\n##4.springboot和springcloud，请你谈谈对他们的理解\n\n```\n\n```\n\n\n\n##5.什么是服务熔断？什么是服务降级？\n\n```\n\n```\n\n\n\n##6.微服务的优缺点分别是什么？说下你再项目开发中碰到的坑?\n\n```\n\n```\n\n\n\n##7.你所知道的微服务技术栈有哪些？请列举一二\n\n| 微服务条目   | 落地技术                         | 备注   |\n| ------- | ---------------------------- | ---- |\n| 服务开发    | SpringBoot,Spring,SpringMVC  |      |\n| 服务配置与管理 | Neflix公司Archaius、阿里的Diamond等 |      |\n| 服务注册与发现 | Eureka、Consul、Zookeeper等     |      |\n| 服务调用    | Rest、RPC、gRPC                |      |\n| 服务熔断器   | Hystrix、Envoy等               |      |\n| 负载均衡    | Ribbon，nginx等                |      |\n| 服务接口调用  | feign                        |      |\n| 消息队列    | kafka、RabbitMQ               |      |\n|         |                              |      |\n\n\n\n## 8.eureka和zookeeper都可以提供服务注册和发现的功能，说下两者的区别\n\n```\n\n```\n\n# 二、微服务概述\n\n## 1、什么是微服务\n\n将单一的应用程序划分成一组小的服务，每个服务运行在其独立的进程，服务之间互相协调，互相配合。\n\n服务之间采用轻量级的通信机制进行沟通。\n\n可以使用不同语言来编写服务\n\n```\n微服务化的核心就是将传统的一站式应用，根据业务拆分成一个个的服务，彻底地去耦合，每一个微服务提供单个业务功能，一个服务做一件事情。从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或者销毁，拥有自己独立的数据库。\n```\n\n## 2、微服务优缺点\n\n###1、优点\n\n```\n\n```\n\n\n\n### 2、缺点\n\n# 三、学习资料\n\n[SpringCloud中文网](https://www.springcloud.cc/)\n\n[SpringCloud中文社区](springcloud.cn)\n\n# 四、Spring Cloud\n\n## 1、Eureka\n\n### 1、自我保护机制：好死不如赖活着\n\n```\n某时刻某一个微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存\n\n默认情况下，EurekaServer在规定时间内没有收到客户端发来的心跳，会将该客户端从服务注册表中删除。但是当一段时间内出现大量的客户端不发送心跳，Eureka就进入自我保护模式，进入自我保护模式后，客户端的信息会被保存下来。\n\n默认情况下，如果Eureka在一定时间内没有收到某个微服务实例的心跳，EurekaServer将会注销该实例，默认是90秒。但是当网络分区故障时，微服务与EurekaServer之间不能通信，以上行为可能变得非常危险：因为微服务本身是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护机制”来解决这个问题————当EurekaServer节点在短时间内丢失过多的客户端时（可能发生了网络故障），那么这个节点就会进入自我保护模式。一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不会删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复时，该EurekaServer自动退出自我保护模式。\n\n\n```\n\n\n\n### 2、配置\n\n\n\n## 2、Ribbon:客户端负载均衡，进程内LB\n\n面试题：Ribbon，feign，nginx都可以做负载均衡，区别是什么？\n\n```\nfeign融合了ribbon\n```\n\n### 1、负载均衡(Load Balance)\n\n**负载均衡简单说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA.**\n\n负载均衡分**集中式LB**，**进程内LB**\n\n**集中式LB** ： 偏硬件，在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5,也可以是软件，如nginx），由该设施负责把访问请求通过某种策略转发到服务的提供方。\n\n**进程内LB** ：偏软件，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。\n\n**Ribbon就属于进程内LB，**它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。\n\n### 2、负载均衡算法\n\n#### 自定义负载均衡算法\n\n**可以作为项目中遇到的坑**：自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，也就是说我们达不到特殊定制化的目的。\n\n## 3、feign\n\n## 4、hystrix\n\n### 服务熔断\n\n```\n多个微服务有依赖关系，其中一个微服务挂掉，为了避免影响依赖于这个微服务的其他微服务，需要使用服务熔断。\n\n一般是某个服务故障或异常引起，类似现实世界中的“保险丝”，当某个异常条件被触发时，直接熔断整个服务，而不是一直等到此服务超时。\n```\n\n### 服务雪崩\n\n```\n\n```\n\n\n\n### 服务降级\n\n```\n整体资源快不够了，忍痛将某些服务先关掉，待度过难关，再重启回来。\n\n服务降级是在客户端完成的，与服务端没有关系。\n\n所谓降级，一般是从整体负荷考虑，就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己装一个本地的fallback回调，返回一个缺省值。这样做，虽然服务水平下降，单好歹可用，比直接挂掉要强。\n\n```\n\n### 使用\n\n@HystrixCommond\n\n@EnableCircuitBreaker\n\n\n\n## 5、Zuul\n\n```\n请求的路由和过滤\n\n```\n\n@EnableZuulProxy\n\n\n\n```\nzuul:\n prefix: /atguigu                           #统一前缀\n ignored-services: microservicecloud-dept  #屏蔽真实名称\n # ignored-services: \"*\"    #屏蔽所有的真实名称\n routes:\n  mydept.serviceId: microservicecloud-dept\n  mydept.path: /mydept/**\n```\n\n## 6、Config\n\n作用：\n\n1.集中管理文件\n\n2.不同环境不同配置，动态化的配置更新，分环境部署\n\n3.运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n\n4.当配置发生变动时，服务不需要重启即可感知配置的变化并应用新的配置\n\n5.将配置以REST接口的形式暴露\n\n\n\n**application.yml和bootstrap.yml**\n\n```\napplication.yml是用户级的资源配置项\nbootstrap.yml是系统级的，优先级更加高\n```\n\nDevops:开发自运维\n\n图片存储：FastFS","source":"_posts/springcloud/springcloud.md","raw":"# 一、面试题\n\n##1.什么是微服务？\n\n```\n\n```\n\n\n\n##2.微服务之间是如何独立通讯的？\n\n```\n\n```\n\n\n\n##3.springcloud和dubbo有哪些区别？\n\n```\ndubbo：基于RPC,SpringCloud:基于Restful API\n```\n\n|        | Dubbo     | Spring Cloud |\n| ------ | --------- | ------------ |\n| 服务注册中心 | zookeeper | eureka       |\n| 服务调用方式 | RPC       | RestAPI      |\n| 服务监控   | monitor   | Admin        |\n| 断路器    | 不完善       | Hystrix      |\n| 服务网关   | 无         | Zuul         |\n| 分布式配置  | 无         | Config       |\n| 服务跟踪   | 无         | Sleuth       |\n| 消息总线   | 无         | Bus          |\n| 数据流    | 无         | Stream       |\n| 批量任务   | 无         | Task         |\n\n\n\n##4.springboot和springcloud，请你谈谈对他们的理解\n\n```\n\n```\n\n\n\n##5.什么是服务熔断？什么是服务降级？\n\n```\n\n```\n\n\n\n##6.微服务的优缺点分别是什么？说下你再项目开发中碰到的坑?\n\n```\n\n```\n\n\n\n##7.你所知道的微服务技术栈有哪些？请列举一二\n\n| 微服务条目   | 落地技术                         | 备注   |\n| ------- | ---------------------------- | ---- |\n| 服务开发    | SpringBoot,Spring,SpringMVC  |      |\n| 服务配置与管理 | Neflix公司Archaius、阿里的Diamond等 |      |\n| 服务注册与发现 | Eureka、Consul、Zookeeper等     |      |\n| 服务调用    | Rest、RPC、gRPC                |      |\n| 服务熔断器   | Hystrix、Envoy等               |      |\n| 负载均衡    | Ribbon，nginx等                |      |\n| 服务接口调用  | feign                        |      |\n| 消息队列    | kafka、RabbitMQ               |      |\n|         |                              |      |\n\n\n\n## 8.eureka和zookeeper都可以提供服务注册和发现的功能，说下两者的区别\n\n```\n\n```\n\n# 二、微服务概述\n\n## 1、什么是微服务\n\n将单一的应用程序划分成一组小的服务，每个服务运行在其独立的进程，服务之间互相协调，互相配合。\n\n服务之间采用轻量级的通信机制进行沟通。\n\n可以使用不同语言来编写服务\n\n```\n微服务化的核心就是将传统的一站式应用，根据业务拆分成一个个的服务，彻底地去耦合，每一个微服务提供单个业务功能，一个服务做一件事情。从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或者销毁，拥有自己独立的数据库。\n```\n\n## 2、微服务优缺点\n\n###1、优点\n\n```\n\n```\n\n\n\n### 2、缺点\n\n# 三、学习资料\n\n[SpringCloud中文网](https://www.springcloud.cc/)\n\n[SpringCloud中文社区](springcloud.cn)\n\n# 四、Spring Cloud\n\n## 1、Eureka\n\n### 1、自我保护机制：好死不如赖活着\n\n```\n某时刻某一个微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存\n\n默认情况下，EurekaServer在规定时间内没有收到客户端发来的心跳，会将该客户端从服务注册表中删除。但是当一段时间内出现大量的客户端不发送心跳，Eureka就进入自我保护模式，进入自我保护模式后，客户端的信息会被保存下来。\n\n默认情况下，如果Eureka在一定时间内没有收到某个微服务实例的心跳，EurekaServer将会注销该实例，默认是90秒。但是当网络分区故障时，微服务与EurekaServer之间不能通信，以上行为可能变得非常危险：因为微服务本身是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护机制”来解决这个问题————当EurekaServer节点在短时间内丢失过多的客户端时（可能发生了网络故障），那么这个节点就会进入自我保护模式。一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不会删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复时，该EurekaServer自动退出自我保护模式。\n\n\n```\n\n\n\n### 2、配置\n\n\n\n## 2、Ribbon:客户端负载均衡，进程内LB\n\n面试题：Ribbon，feign，nginx都可以做负载均衡，区别是什么？\n\n```\nfeign融合了ribbon\n```\n\n### 1、负载均衡(Load Balance)\n\n**负载均衡简单说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA.**\n\n负载均衡分**集中式LB**，**进程内LB**\n\n**集中式LB** ： 偏硬件，在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5,也可以是软件，如nginx），由该设施负责把访问请求通过某种策略转发到服务的提供方。\n\n**进程内LB** ：偏软件，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。\n\n**Ribbon就属于进程内LB，**它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。\n\n### 2、负载均衡算法\n\n#### 自定义负载均衡算法\n\n**可以作为项目中遇到的坑**：自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，也就是说我们达不到特殊定制化的目的。\n\n## 3、feign\n\n## 4、hystrix\n\n### 服务熔断\n\n```\n多个微服务有依赖关系，其中一个微服务挂掉，为了避免影响依赖于这个微服务的其他微服务，需要使用服务熔断。\n\n一般是某个服务故障或异常引起，类似现实世界中的“保险丝”，当某个异常条件被触发时，直接熔断整个服务，而不是一直等到此服务超时。\n```\n\n### 服务雪崩\n\n```\n\n```\n\n\n\n### 服务降级\n\n```\n整体资源快不够了，忍痛将某些服务先关掉，待度过难关，再重启回来。\n\n服务降级是在客户端完成的，与服务端没有关系。\n\n所谓降级，一般是从整体负荷考虑，就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己装一个本地的fallback回调，返回一个缺省值。这样做，虽然服务水平下降，单好歹可用，比直接挂掉要强。\n\n```\n\n### 使用\n\n@HystrixCommond\n\n@EnableCircuitBreaker\n\n\n\n## 5、Zuul\n\n```\n请求的路由和过滤\n\n```\n\n@EnableZuulProxy\n\n\n\n```\nzuul:\n prefix: /atguigu                           #统一前缀\n ignored-services: microservicecloud-dept  #屏蔽真实名称\n # ignored-services: \"*\"    #屏蔽所有的真实名称\n routes:\n  mydept.serviceId: microservicecloud-dept\n  mydept.path: /mydept/**\n```\n\n## 6、Config\n\n作用：\n\n1.集中管理文件\n\n2.不同环境不同配置，动态化的配置更新，分环境部署\n\n3.运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息\n\n4.当配置发生变动时，服务不需要重启即可感知配置的变化并应用新的配置\n\n5.将配置以REST接口的形式暴露\n\n\n\n**application.yml和bootstrap.yml**\n\n```\napplication.yml是用户级的资源配置项\nbootstrap.yml是系统级的，优先级更加高\n```\n\nDevops:开发自运维\n\n图片存储：FastFS","slug":"springcloud/springcloud","published":1,"date":"2019-11-18T11:22:35.212Z","updated":"2019-11-23T14:06:23.042Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5jl0015lcvdc7l5tyy9","content":"<h1 id=\"一、面试题\"><a href=\"#一、面试题\" class=\"headerlink\" title=\"一、面试题\"></a>一、面试题</h1><p>##1.什么是微服务？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>##2.微服务之间是如何独立通讯的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>##3.springcloud和dubbo有哪些区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dubbo：基于RPC,SpringCloud:基于Restful API</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Dubbo</th>\n<th>Spring Cloud</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务注册中心</td>\n<td>zookeeper</td>\n<td>eureka</td>\n</tr>\n<tr>\n<td>服务调用方式</td>\n<td>RPC</td>\n<td>RestAPI</td>\n</tr>\n<tr>\n<td>服务监控</td>\n<td>monitor</td>\n<td>Admin</td>\n</tr>\n<tr>\n<td>断路器</td>\n<td>不完善</td>\n<td>Hystrix</td>\n</tr>\n<tr>\n<td>服务网关</td>\n<td>无</td>\n<td>Zuul</td>\n</tr>\n<tr>\n<td>分布式配置</td>\n<td>无</td>\n<td>Config</td>\n</tr>\n<tr>\n<td>服务跟踪</td>\n<td>无</td>\n<td>Sleuth</td>\n</tr>\n<tr>\n<td>消息总线</td>\n<td>无</td>\n<td>Bus</td>\n</tr>\n<tr>\n<td>数据流</td>\n<td>无</td>\n<td>Stream</td>\n</tr>\n<tr>\n<td>批量任务</td>\n<td>无</td>\n<td>Task</td>\n</tr>\n</tbody></table>\n<p>##4.springboot和springcloud，请你谈谈对他们的理解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>##5.什么是服务熔断？什么是服务降级？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>##6.微服务的优缺点分别是什么？说下你再项目开发中碰到的坑?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>##7.你所知道的微服务技术栈有哪些？请列举一二</p>\n<table>\n<thead>\n<tr>\n<th>微服务条目</th>\n<th>落地技术</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务开发</td>\n<td>SpringBoot,Spring,SpringMVC</td>\n<td></td>\n</tr>\n<tr>\n<td>服务配置与管理</td>\n<td>Neflix公司Archaius、阿里的Diamond等</td>\n<td></td>\n</tr>\n<tr>\n<td>服务注册与发现</td>\n<td>Eureka、Consul、Zookeeper等</td>\n<td></td>\n</tr>\n<tr>\n<td>服务调用</td>\n<td>Rest、RPC、gRPC</td>\n<td></td>\n</tr>\n<tr>\n<td>服务熔断器</td>\n<td>Hystrix、Envoy等</td>\n<td></td>\n</tr>\n<tr>\n<td>负载均衡</td>\n<td>Ribbon，nginx等</td>\n<td></td>\n</tr>\n<tr>\n<td>服务接口调用</td>\n<td>feign</td>\n<td></td>\n</tr>\n<tr>\n<td>消息队列</td>\n<td>kafka、RabbitMQ</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"8-eureka和zookeeper都可以提供服务注册和发现的功能，说下两者的区别\"><a href=\"#8-eureka和zookeeper都可以提供服务注册和发现的功能，说下两者的区别\" class=\"headerlink\" title=\"8.eureka和zookeeper都可以提供服务注册和发现的功能，说下两者的区别\"></a>8.eureka和zookeeper都可以提供服务注册和发现的功能，说下两者的区别</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、微服务概述\"><a href=\"#二、微服务概述\" class=\"headerlink\" title=\"二、微服务概述\"></a>二、微服务概述</h1><h2 id=\"1、什么是微服务\"><a href=\"#1、什么是微服务\" class=\"headerlink\" title=\"1、什么是微服务\"></a>1、什么是微服务</h2><p>将单一的应用程序划分成一组小的服务，每个服务运行在其独立的进程，服务之间互相协调，互相配合。</p>\n<p>服务之间采用轻量级的通信机制进行沟通。</p>\n<p>可以使用不同语言来编写服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">微服务化的核心就是将传统的一站式应用，根据业务拆分成一个个的服务，彻底地去耦合，每一个微服务提供单个业务功能，一个服务做一件事情。从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或者销毁，拥有自己独立的数据库。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、微服务优缺点\"><a href=\"#2、微服务优缺点\" class=\"headerlink\" title=\"2、微服务优缺点\"></a>2、微服务优缺点</h2><p>###1、优点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、缺点\"><a href=\"#2、缺点\" class=\"headerlink\" title=\"2、缺点\"></a>2、缺点</h3><h1 id=\"三、学习资料\"><a href=\"#三、学习资料\" class=\"headerlink\" title=\"三、学习资料\"></a>三、学习资料</h1><p><a href=\"https://www.springcloud.cc/\" target=\"_blank\" rel=\"noopener\">SpringCloud中文网</a></p>\n<p><a href=\"springcloud.cn\">SpringCloud中文社区</a></p>\n<h1 id=\"四、Spring-Cloud\"><a href=\"#四、Spring-Cloud\" class=\"headerlink\" title=\"四、Spring Cloud\"></a>四、Spring Cloud</h1><h2 id=\"1、Eureka\"><a href=\"#1、Eureka\" class=\"headerlink\" title=\"1、Eureka\"></a>1、Eureka</h2><h3 id=\"1、自我保护机制：好死不如赖活着\"><a href=\"#1、自我保护机制：好死不如赖活着\" class=\"headerlink\" title=\"1、自我保护机制：好死不如赖活着\"></a>1、自我保护机制：好死不如赖活着</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">某时刻某一个微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存</span><br><span class=\"line\"></span><br><span class=\"line\">默认情况下，EurekaServer在规定时间内没有收到客户端发来的心跳，会将该客户端从服务注册表中删除。但是当一段时间内出现大量的客户端不发送心跳，Eureka就进入自我保护模式，进入自我保护模式后，客户端的信息会被保存下来。</span><br><span class=\"line\"></span><br><span class=\"line\">默认情况下，如果Eureka在一定时间内没有收到某个微服务实例的心跳，EurekaServer将会注销该实例，默认是90秒。但是当网络分区故障时，微服务与EurekaServer之间不能通信，以上行为可能变得非常危险：因为微服务本身是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护机制”来解决这个问题————当EurekaServer节点在短时间内丢失过多的客户端时（可能发生了网络故障），那么这个节点就会进入自我保护模式。一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不会删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复时，该EurekaServer自动退出自我保护模式。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、配置\"><a href=\"#2、配置\" class=\"headerlink\" title=\"2、配置\"></a>2、配置</h3><h2 id=\"2、Ribbon-客户端负载均衡，进程内LB\"><a href=\"#2、Ribbon-客户端负载均衡，进程内LB\" class=\"headerlink\" title=\"2、Ribbon:客户端负载均衡，进程内LB\"></a>2、Ribbon:客户端负载均衡，进程内LB</h2><p>面试题：Ribbon，feign，nginx都可以做负载均衡，区别是什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feign融合了ribbon</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1、负载均衡-Load-Balance\"><a href=\"#1、负载均衡-Load-Balance\" class=\"headerlink\" title=\"1、负载均衡(Load Balance)\"></a>1、负载均衡(Load Balance)</h3><p><strong>负载均衡简单说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA.</strong></p>\n<p>负载均衡分<strong>集中式LB</strong>，<strong>进程内LB</strong></p>\n<p><strong>集中式LB</strong> ： 偏硬件，在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5,也可以是软件，如nginx），由该设施负责把访问请求通过某种策略转发到服务的提供方。</p>\n<p><strong>进程内LB</strong> ：偏软件，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</p>\n<p><strong>Ribbon就属于进程内LB，</strong>它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p>\n<h3 id=\"2、负载均衡算法\"><a href=\"#2、负载均衡算法\" class=\"headerlink\" title=\"2、负载均衡算法\"></a>2、负载均衡算法</h3><h4 id=\"自定义负载均衡算法\"><a href=\"#自定义负载均衡算法\" class=\"headerlink\" title=\"自定义负载均衡算法\"></a>自定义负载均衡算法</h4><p><strong>可以作为项目中遇到的坑</strong>：自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，也就是说我们达不到特殊定制化的目的。</p>\n<h2 id=\"3、feign\"><a href=\"#3、feign\" class=\"headerlink\" title=\"3、feign\"></a>3、feign</h2><h2 id=\"4、hystrix\"><a href=\"#4、hystrix\" class=\"headerlink\" title=\"4、hystrix\"></a>4、hystrix</h2><h3 id=\"服务熔断\"><a href=\"#服务熔断\" class=\"headerlink\" title=\"服务熔断\"></a>服务熔断</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多个微服务有依赖关系，其中一个微服务挂掉，为了避免影响依赖于这个微服务的其他微服务，需要使用服务熔断。</span><br><span class=\"line\"></span><br><span class=\"line\">一般是某个服务故障或异常引起，类似现实世界中的“保险丝”，当某个异常条件被触发时，直接熔断整个服务，而不是一直等到此服务超时。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务雪崩\"><a href=\"#服务雪崩\" class=\"headerlink\" title=\"服务雪崩\"></a>服务雪崩</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">整体资源快不够了，忍痛将某些服务先关掉，待度过难关，再重启回来。</span><br><span class=\"line\"></span><br><span class=\"line\">服务降级是在客户端完成的，与服务端没有关系。</span><br><span class=\"line\"></span><br><span class=\"line\">所谓降级，一般是从整体负荷考虑，就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己装一个本地的fallback回调，返回一个缺省值。这样做，虽然服务水平下降，单好歹可用，比直接挂掉要强。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>@HystrixCommond</p>\n<p>@EnableCircuitBreaker</p>\n<h2 id=\"5、Zuul\"><a href=\"#5、Zuul\" class=\"headerlink\" title=\"5、Zuul\"></a>5、Zuul</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请求的路由和过滤</span><br></pre></td></tr></table></figure>\n\n<p>@EnableZuulProxy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zuul:</span><br><span class=\"line\"> prefix: /atguigu                           #统一前缀</span><br><span class=\"line\"> ignored-services: microservicecloud-dept  #屏蔽真实名称</span><br><span class=\"line\"> # ignored-services: &quot;*&quot;    #屏蔽所有的真实名称</span><br><span class=\"line\"> routes:</span><br><span class=\"line\">  mydept.serviceId: microservicecloud-dept</span><br><span class=\"line\">  mydept.path: /mydept/**</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6、Config\"><a href=\"#6、Config\" class=\"headerlink\" title=\"6、Config\"></a>6、Config</h2><p>作用：</p>\n<p>1.集中管理文件</p>\n<p>2.不同环境不同配置，动态化的配置更新，分环境部署</p>\n<p>3.运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</p>\n<p>4.当配置发生变动时，服务不需要重启即可感知配置的变化并应用新的配置</p>\n<p>5.将配置以REST接口的形式暴露</p>\n<p><strong>application.yml和bootstrap.yml</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">application.yml是用户级的资源配置项</span><br><span class=\"line\">bootstrap.yml是系统级的，优先级更加高</span><br></pre></td></tr></table></figure>\n\n<p>Devops:开发自运维</p>\n<p>图片存储：FastFS</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、面试题\"><a href=\"#一、面试题\" class=\"headerlink\" title=\"一、面试题\"></a>一、面试题</h1><p>##1.什么是微服务？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>##2.微服务之间是如何独立通讯的？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>##3.springcloud和dubbo有哪些区别？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dubbo：基于RPC,SpringCloud:基于Restful API</span><br></pre></td></tr></table></figure>\n\n<table>\n<thead>\n<tr>\n<th></th>\n<th>Dubbo</th>\n<th>Spring Cloud</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务注册中心</td>\n<td>zookeeper</td>\n<td>eureka</td>\n</tr>\n<tr>\n<td>服务调用方式</td>\n<td>RPC</td>\n<td>RestAPI</td>\n</tr>\n<tr>\n<td>服务监控</td>\n<td>monitor</td>\n<td>Admin</td>\n</tr>\n<tr>\n<td>断路器</td>\n<td>不完善</td>\n<td>Hystrix</td>\n</tr>\n<tr>\n<td>服务网关</td>\n<td>无</td>\n<td>Zuul</td>\n</tr>\n<tr>\n<td>分布式配置</td>\n<td>无</td>\n<td>Config</td>\n</tr>\n<tr>\n<td>服务跟踪</td>\n<td>无</td>\n<td>Sleuth</td>\n</tr>\n<tr>\n<td>消息总线</td>\n<td>无</td>\n<td>Bus</td>\n</tr>\n<tr>\n<td>数据流</td>\n<td>无</td>\n<td>Stream</td>\n</tr>\n<tr>\n<td>批量任务</td>\n<td>无</td>\n<td>Task</td>\n</tr>\n</tbody></table>\n<p>##4.springboot和springcloud，请你谈谈对他们的理解</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>##5.什么是服务熔断？什么是服务降级？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>##6.微服务的优缺点分别是什么？说下你再项目开发中碰到的坑?</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>##7.你所知道的微服务技术栈有哪些？请列举一二</p>\n<table>\n<thead>\n<tr>\n<th>微服务条目</th>\n<th>落地技术</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>服务开发</td>\n<td>SpringBoot,Spring,SpringMVC</td>\n<td></td>\n</tr>\n<tr>\n<td>服务配置与管理</td>\n<td>Neflix公司Archaius、阿里的Diamond等</td>\n<td></td>\n</tr>\n<tr>\n<td>服务注册与发现</td>\n<td>Eureka、Consul、Zookeeper等</td>\n<td></td>\n</tr>\n<tr>\n<td>服务调用</td>\n<td>Rest、RPC、gRPC</td>\n<td></td>\n</tr>\n<tr>\n<td>服务熔断器</td>\n<td>Hystrix、Envoy等</td>\n<td></td>\n</tr>\n<tr>\n<td>负载均衡</td>\n<td>Ribbon，nginx等</td>\n<td></td>\n</tr>\n<tr>\n<td>服务接口调用</td>\n<td>feign</td>\n<td></td>\n</tr>\n<tr>\n<td>消息队列</td>\n<td>kafka、RabbitMQ</td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"8-eureka和zookeeper都可以提供服务注册和发现的功能，说下两者的区别\"><a href=\"#8-eureka和zookeeper都可以提供服务注册和发现的功能，说下两者的区别\" class=\"headerlink\" title=\"8.eureka和zookeeper都可以提供服务注册和发现的功能，说下两者的区别\"></a>8.eureka和zookeeper都可以提供服务注册和发现的功能，说下两者的区别</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h1 id=\"二、微服务概述\"><a href=\"#二、微服务概述\" class=\"headerlink\" title=\"二、微服务概述\"></a>二、微服务概述</h1><h2 id=\"1、什么是微服务\"><a href=\"#1、什么是微服务\" class=\"headerlink\" title=\"1、什么是微服务\"></a>1、什么是微服务</h2><p>将单一的应用程序划分成一组小的服务，每个服务运行在其独立的进程，服务之间互相协调，互相配合。</p>\n<p>服务之间采用轻量级的通信机制进行沟通。</p>\n<p>可以使用不同语言来编写服务</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">微服务化的核心就是将传统的一站式应用，根据业务拆分成一个个的服务，彻底地去耦合，每一个微服务提供单个业务功能，一个服务做一件事情。从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或者销毁，拥有自己独立的数据库。</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"2、微服务优缺点\"><a href=\"#2、微服务优缺点\" class=\"headerlink\" title=\"2、微服务优缺点\"></a>2、微服务优缺点</h2><p>###1、优点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、缺点\"><a href=\"#2、缺点\" class=\"headerlink\" title=\"2、缺点\"></a>2、缺点</h3><h1 id=\"三、学习资料\"><a href=\"#三、学习资料\" class=\"headerlink\" title=\"三、学习资料\"></a>三、学习资料</h1><p><a href=\"https://www.springcloud.cc/\" target=\"_blank\" rel=\"noopener\">SpringCloud中文网</a></p>\n<p><a href=\"springcloud.cn\">SpringCloud中文社区</a></p>\n<h1 id=\"四、Spring-Cloud\"><a href=\"#四、Spring-Cloud\" class=\"headerlink\" title=\"四、Spring Cloud\"></a>四、Spring Cloud</h1><h2 id=\"1、Eureka\"><a href=\"#1、Eureka\" class=\"headerlink\" title=\"1、Eureka\"></a>1、Eureka</h2><h3 id=\"1、自我保护机制：好死不如赖活着\"><a href=\"#1、自我保护机制：好死不如赖活着\" class=\"headerlink\" title=\"1、自我保护机制：好死不如赖活着\"></a>1、自我保护机制：好死不如赖活着</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">某时刻某一个微服务不可用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存</span><br><span class=\"line\"></span><br><span class=\"line\">默认情况下，EurekaServer在规定时间内没有收到客户端发来的心跳，会将该客户端从服务注册表中删除。但是当一段时间内出现大量的客户端不发送心跳，Eureka就进入自我保护模式，进入自我保护模式后，客户端的信息会被保存下来。</span><br><span class=\"line\"></span><br><span class=\"line\">默认情况下，如果Eureka在一定时间内没有收到某个微服务实例的心跳，EurekaServer将会注销该实例，默认是90秒。但是当网络分区故障时，微服务与EurekaServer之间不能通信，以上行为可能变得非常危险：因为微服务本身是健康的，此时本不应该注销这个微服务。Eureka通过“自我保护机制”来解决这个问题————当EurekaServer节点在短时间内丢失过多的客户端时（可能发生了网络故障），那么这个节点就会进入自我保护模式。一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不会删除服务注册表中的数据（也就是不会注销任何微服务）。当网络故障恢复时，该EurekaServer自动退出自我保护模式。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"2、配置\"><a href=\"#2、配置\" class=\"headerlink\" title=\"2、配置\"></a>2、配置</h3><h2 id=\"2、Ribbon-客户端负载均衡，进程内LB\"><a href=\"#2、Ribbon-客户端负载均衡，进程内LB\" class=\"headerlink\" title=\"2、Ribbon:客户端负载均衡，进程内LB\"></a>2、Ribbon:客户端负载均衡，进程内LB</h2><p>面试题：Ribbon，feign，nginx都可以做负载均衡，区别是什么？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">feign融合了ribbon</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1、负载均衡-Load-Balance\"><a href=\"#1、负载均衡-Load-Balance\" class=\"headerlink\" title=\"1、负载均衡(Load Balance)\"></a>1、负载均衡(Load Balance)</h3><p><strong>负载均衡简单说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA.</strong></p>\n<p>负载均衡分<strong>集中式LB</strong>，<strong>进程内LB</strong></p>\n<p><strong>集中式LB</strong> ： 偏硬件，在服务的消费方和提供方之间使用独立的LB设施（可以是硬件，如F5,也可以是软件，如nginx），由该设施负责把访问请求通过某种策略转发到服务的提供方。</p>\n<p><strong>进程内LB</strong> ：偏软件，将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的服务器。</p>\n<p><strong>Ribbon就属于进程内LB，</strong>它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址。</p>\n<h3 id=\"2、负载均衡算法\"><a href=\"#2、负载均衡算法\" class=\"headerlink\" title=\"2、负载均衡算法\"></a>2、负载均衡算法</h3><h4 id=\"自定义负载均衡算法\"><a href=\"#自定义负载均衡算法\" class=\"headerlink\" title=\"自定义负载均衡算法\"></a>自定义负载均衡算法</h4><p><strong>可以作为项目中遇到的坑</strong>：自定义配置类不能放在@ComponentScan所扫描的当前包下以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端所共享，也就是说我们达不到特殊定制化的目的。</p>\n<h2 id=\"3、feign\"><a href=\"#3、feign\" class=\"headerlink\" title=\"3、feign\"></a>3、feign</h2><h2 id=\"4、hystrix\"><a href=\"#4、hystrix\" class=\"headerlink\" title=\"4、hystrix\"></a>4、hystrix</h2><h3 id=\"服务熔断\"><a href=\"#服务熔断\" class=\"headerlink\" title=\"服务熔断\"></a>服务熔断</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">多个微服务有依赖关系，其中一个微服务挂掉，为了避免影响依赖于这个微服务的其他微服务，需要使用服务熔断。</span><br><span class=\"line\"></span><br><span class=\"line\">一般是某个服务故障或异常引起，类似现实世界中的“保险丝”，当某个异常条件被触发时，直接熔断整个服务，而不是一直等到此服务超时。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务雪崩\"><a href=\"#服务雪崩\" class=\"headerlink\" title=\"服务雪崩\"></a>服务雪崩</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"服务降级\"><a href=\"#服务降级\" class=\"headerlink\" title=\"服务降级\"></a>服务降级</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">整体资源快不够了，忍痛将某些服务先关掉，待度过难关，再重启回来。</span><br><span class=\"line\"></span><br><span class=\"line\">服务降级是在客户端完成的，与服务端没有关系。</span><br><span class=\"line\"></span><br><span class=\"line\">所谓降级，一般是从整体负荷考虑，就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己装一个本地的fallback回调，返回一个缺省值。这样做，虽然服务水平下降，单好歹可用，比直接挂掉要强。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>@HystrixCommond</p>\n<p>@EnableCircuitBreaker</p>\n<h2 id=\"5、Zuul\"><a href=\"#5、Zuul\" class=\"headerlink\" title=\"5、Zuul\"></a>5、Zuul</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">请求的路由和过滤</span><br></pre></td></tr></table></figure>\n\n<p>@EnableZuulProxy</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zuul:</span><br><span class=\"line\"> prefix: /atguigu                           #统一前缀</span><br><span class=\"line\"> ignored-services: microservicecloud-dept  #屏蔽真实名称</span><br><span class=\"line\"> # ignored-services: &quot;*&quot;    #屏蔽所有的真实名称</span><br><span class=\"line\"> routes:</span><br><span class=\"line\">  mydept.serviceId: microservicecloud-dept</span><br><span class=\"line\">  mydept.path: /mydept/**</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"6、Config\"><a href=\"#6、Config\" class=\"headerlink\" title=\"6、Config\"></a>6、Config</h2><p>作用：</p>\n<p>1.集中管理文件</p>\n<p>2.不同环境不同配置，动态化的配置更新，分环境部署</p>\n<p>3.运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</p>\n<p>4.当配置发生变动时，服务不需要重启即可感知配置的变化并应用新的配置</p>\n<p>5.将配置以REST接口的形式暴露</p>\n<p><strong>application.yml和bootstrap.yml</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">application.yml是用户级的资源配置项</span><br><span class=\"line\">bootstrap.yml是系统级的，优先级更加高</span><br></pre></td></tr></table></figure>\n\n<p>Devops:开发自运维</p>\n<p>图片存储：FastFS</p>\n"},{"title":"博客搭建","_content":"\n* [使用hexo+github搭建免费个人博客详细教程](https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html)\n* [github+hexo更该主题](https://blog.csdn.net/heimu24/article/details/81209539)\n* [yelog主题设置](https://yelog.org/2017/03/23/3-hexo-instruction/)\n\n* 命令:\n** 部署，重新打包public文件夹：hexo d -g\n** 本地运行：hexo s","source":"_posts/搭建博客/搭建博客.md","raw":"---\ntitle: 博客搭建\ntags: \n- 博客搭建\ncategories:\n- 博客搭建\n---\n\n* [使用hexo+github搭建免费个人博客详细教程](https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html)\n* [github+hexo更该主题](https://blog.csdn.net/heimu24/article/details/81209539)\n* [yelog主题设置](https://yelog.org/2017/03/23/3-hexo-instruction/)\n\n* 命令:\n** 部署，重新打包public文件夹：hexo d -g\n** 本地运行：hexo s","slug":"搭建博客/搭建博客","published":1,"date":"2019-09-13T02:01:00.644Z","updated":"2019-10-28T11:54:25.697Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5jn0019lcvdc3vwz816","content":"<ul>\n<li><p><a href=\"https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html\" target=\"_blank\" rel=\"noopener\">使用hexo+github搭建免费个人博客详细教程</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/heimu24/article/details/81209539\" target=\"_blank\" rel=\"noopener\">github+hexo更该主题</a></p>\n</li>\n<li><p><a href=\"https://yelog.org/2017/03/23/3-hexo-instruction/\" target=\"_blank\" rel=\"noopener\">yelog主题设置</a></p>\n</li>\n<li><p>命令:</p>\n</li>\n<li><ul>\n<li>部署，重新打包public文件夹：hexo d -g</li>\n</ul>\n</li>\n<li><ul>\n<li>本地运行：hexo s</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p><a href=\"https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html\" target=\"_blank\" rel=\"noopener\">使用hexo+github搭建免费个人博客详细教程</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/heimu24/article/details/81209539\" target=\"_blank\" rel=\"noopener\">github+hexo更该主题</a></p>\n</li>\n<li><p><a href=\"https://yelog.org/2017/03/23/3-hexo-instruction/\" target=\"_blank\" rel=\"noopener\">yelog主题设置</a></p>\n</li>\n<li><p>命令:</p>\n</li>\n<li><ul>\n<li>部署，重新打包public文件夹：hexo d -g</li>\n</ul>\n</li>\n<li><ul>\n<li>本地运行：hexo s</li>\n</ul>\n</li>\n</ul>\n"},{"title":"HashMap面试题整理","_content":"\n# HashMap最常见的问题：\n* 1.hashCode()和equals()方法为什么要同时实现？\n* 2.HashMap的扩容机制\n* 3.为什么HashMap不是线程安全的？怎么实现线程安全？\n* 4.HashMap使用注意事项\n* 5.JDK1.8中HashMap做了哪些优化？\n* 6.为什么JDK1.8使用红黑树解决冲突？","source":"_posts/容器/HashMap面试题整理.md","raw":"---\ntitle: HashMap面试题整理\ntags: \n- HashMap\ncategories:\n- 容器\n---\n\n# HashMap最常见的问题：\n* 1.hashCode()和equals()方法为什么要同时实现？\n* 2.HashMap的扩容机制\n* 3.为什么HashMap不是线程安全的？怎么实现线程安全？\n* 4.HashMap使用注意事项\n* 5.JDK1.8中HashMap做了哪些优化？\n* 6.为什么JDK1.8使用红黑树解决冲突？","slug":"容器/HashMap面试题整理","published":1,"date":"2019-10-27T11:47:28.068Z","updated":"2019-10-27T11:55:08.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5jp001blcvd0vh1x0ud","content":"<h1 id=\"HashMap最常见的问题：\"><a href=\"#HashMap最常见的问题：\" class=\"headerlink\" title=\"HashMap最常见的问题：\"></a>HashMap最常见的问题：</h1><ul>\n<li>1.hashCode()和equals()方法为什么要同时实现？</li>\n<li>2.HashMap的扩容机制</li>\n<li>3.为什么HashMap不是线程安全的？怎么实现线程安全？</li>\n<li>4.HashMap使用注意事项</li>\n<li>5.JDK1.8中HashMap做了哪些优化？</li>\n<li>6.为什么JDK1.8使用红黑树解决冲突？</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"HashMap最常见的问题：\"><a href=\"#HashMap最常见的问题：\" class=\"headerlink\" title=\"HashMap最常见的问题：\"></a>HashMap最常见的问题：</h1><ul>\n<li>1.hashCode()和equals()方法为什么要同时实现？</li>\n<li>2.HashMap的扩容机制</li>\n<li>3.为什么HashMap不是线程安全的？怎么实现线程安全？</li>\n<li>4.HashMap使用注意事项</li>\n<li>5.JDK1.8中HashMap做了哪些优化？</li>\n<li>6.为什么JDK1.8使用红黑树解决冲突？</li>\n</ul>\n"},{"_content":"# 一、使用场景（解耦、异步、削峰）\n\n##1.应用解耦合\n\n不使用消息队列：\n\n![](images/mq-1.png)\n\n##2.服务通信\n\n##3.异步任务\n\n\n\n##4.削峰填谷\n\n##5.消息广播\n\n# 二、消息协议\n\n## 1、JMS\n\n基于JVM消息代理的规范。\n\n## 2、AMQP\n\n高级消息队列协议，也是一个消息代理的规范，兼容JMS\n\n## 比较：\n\nJMS:仅支持java，不跨语言\n\nAMQP:跨语言\n\n|      | 定义          | 跨平台，跨语言 | Model                  |      | 实现                |\n| ---- | ----------- | ------- | ---------------------- | ---- | ----------------- |\n| JMS  | java api    | 否       | (1)P2P<br />(2)Pub/sub |      | ActiveMQ，HornetMQ |\n| AMQP | 网络级协议，兼容JMS | 是       | 五种                     |      | RabbitMQ          |\n\n\n\n# 三、常用的消息队列\n\n##1、RabbitMQ\n\n###1、特点\n\n使用erlang（交换机领域使用的语言），数据延迟低\n\n有较低概率丢失消息\n\n实现了AMQP\n\n10w+ QPS\n\n开源、性能优秀，稳定性保障\n\n集群模式丰富，表达式配置，HA模式，镜像队列模型\n\n###2、核心概念\n\n#####Message:\n\n#####Virtual Host:\n\n#####Publisher\n\n##### Exchange\n\n##### Queue:\n\n##### Binding\n\n##### Connection\n\n##### Channel\n\n##### Consumer\n\n#####Broker\n\n###3、Exchange类型\n\n#### direct:按照键值匹配\n\n![](images/exchange-direct.png)\n\n#### fanout\n\n![](images/exchange-fanout.png)\n\n#### topic\n\n#### headers\n\n## 2、ActiveMQ\n\n## 3、RocketMQ\n\n## 4、Kafka\n\n## 比较：\n\n| 消息队列\\特性  | 单机吞吐量(QPS)                             | topic 数量对吞吐量的影响 | 时效性  | 可用性                                | 消息可靠性            |      |\n| -------- | -------------------------------------- | --------------- | ---- | ---------------------------------- | ---------------- | ---- |\n| ActiveMQ | 1w+，比RocketMQ、Kafka低一个数量级              |                 |      | 高，基于主从架构实现高可用                      | **有较低的概率丢失数据**   |      |\n| RabbitMQ | 1w+                                    |                 |      | 高，基于主从架构实现高可用                      | 基本不丢             |      |\n| RocketMQ | 10w+,支持高吞吐                             |                 |      | 非常高，分布式架构                          | 经过参数优化配置，可以做到0丢失 |      |\n| Kafka    | 10w+,支持高吞吐，一般配合大数据类的系统进行实时数据计算、日志采集等场景 |                 |      | 非常高，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 | 经过参数优化配置，可以做到0丢失 |      |\n\n#四、面试题\n\n1.为什么使用消息队列？\n\n2.消息队列有什么优点和缺点？\n\n3.kafka、activeMQ、rabbitMQ,rocketMQ都有什么优点和缺点，以及适合哪些场景？\n\n# 五、你系统的中的使用场景？\n\n发送注册邮件\n\n发送注册短信\n\n# 六、消息服务中的概念\n\n## 1、消息代理（message broker）\n\n## 2、目的地（destination）\n\n当消息发送者发送消息以后，将有消息代理接管，消息代理保证消息传递到指定目的地。\n\n目的地有两种形式：\n\n1）.队列（queue）：点对点消息通信\n\n2）.主题（topic）：发布/订阅","source":"_posts/消息队列/消息队列.md","raw":"# 一、使用场景（解耦、异步、削峰）\n\n##1.应用解耦合\n\n不使用消息队列：\n\n![](images/mq-1.png)\n\n##2.服务通信\n\n##3.异步任务\n\n\n\n##4.削峰填谷\n\n##5.消息广播\n\n# 二、消息协议\n\n## 1、JMS\n\n基于JVM消息代理的规范。\n\n## 2、AMQP\n\n高级消息队列协议，也是一个消息代理的规范，兼容JMS\n\n## 比较：\n\nJMS:仅支持java，不跨语言\n\nAMQP:跨语言\n\n|      | 定义          | 跨平台，跨语言 | Model                  |      | 实现                |\n| ---- | ----------- | ------- | ---------------------- | ---- | ----------------- |\n| JMS  | java api    | 否       | (1)P2P<br />(2)Pub/sub |      | ActiveMQ，HornetMQ |\n| AMQP | 网络级协议，兼容JMS | 是       | 五种                     |      | RabbitMQ          |\n\n\n\n# 三、常用的消息队列\n\n##1、RabbitMQ\n\n###1、特点\n\n使用erlang（交换机领域使用的语言），数据延迟低\n\n有较低概率丢失消息\n\n实现了AMQP\n\n10w+ QPS\n\n开源、性能优秀，稳定性保障\n\n集群模式丰富，表达式配置，HA模式，镜像队列模型\n\n###2、核心概念\n\n#####Message:\n\n#####Virtual Host:\n\n#####Publisher\n\n##### Exchange\n\n##### Queue:\n\n##### Binding\n\n##### Connection\n\n##### Channel\n\n##### Consumer\n\n#####Broker\n\n###3、Exchange类型\n\n#### direct:按照键值匹配\n\n![](images/exchange-direct.png)\n\n#### fanout\n\n![](images/exchange-fanout.png)\n\n#### topic\n\n#### headers\n\n## 2、ActiveMQ\n\n## 3、RocketMQ\n\n## 4、Kafka\n\n## 比较：\n\n| 消息队列\\特性  | 单机吞吐量(QPS)                             | topic 数量对吞吐量的影响 | 时效性  | 可用性                                | 消息可靠性            |      |\n| -------- | -------------------------------------- | --------------- | ---- | ---------------------------------- | ---------------- | ---- |\n| ActiveMQ | 1w+，比RocketMQ、Kafka低一个数量级              |                 |      | 高，基于主从架构实现高可用                      | **有较低的概率丢失数据**   |      |\n| RabbitMQ | 1w+                                    |                 |      | 高，基于主从架构实现高可用                      | 基本不丢             |      |\n| RocketMQ | 10w+,支持高吞吐                             |                 |      | 非常高，分布式架构                          | 经过参数优化配置，可以做到0丢失 |      |\n| Kafka    | 10w+,支持高吞吐，一般配合大数据类的系统进行实时数据计算、日志采集等场景 |                 |      | 非常高，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 | 经过参数优化配置，可以做到0丢失 |      |\n\n#四、面试题\n\n1.为什么使用消息队列？\n\n2.消息队列有什么优点和缺点？\n\n3.kafka、activeMQ、rabbitMQ,rocketMQ都有什么优点和缺点，以及适合哪些场景？\n\n# 五、你系统的中的使用场景？\n\n发送注册邮件\n\n发送注册短信\n\n# 六、消息服务中的概念\n\n## 1、消息代理（message broker）\n\n## 2、目的地（destination）\n\n当消息发送者发送消息以后，将有消息代理接管，消息代理保证消息传递到指定目的地。\n\n目的地有两种形式：\n\n1）.队列（queue）：点对点消息通信\n\n2）.主题（topic）：发布/订阅","slug":"消息队列/消息队列","published":1,"date":"2019-11-24T11:28:29.524Z","updated":"2019-11-28T12:07:24.550Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5jr001elcvdv14b3go8","content":"<h1 id=\"一、使用场景（解耦、异步、削峰）\"><a href=\"#一、使用场景（解耦、异步、削峰）\" class=\"headerlink\" title=\"一、使用场景（解耦、异步、削峰）\"></a>一、使用场景（解耦、异步、削峰）</h1><p>##1.应用解耦合</p>\n<p>不使用消息队列：</p>\n<p><img src=\"images/mq-1.png\" alt></p>\n<p>##2.服务通信</p>\n<p>##3.异步任务</p>\n<p>##4.削峰填谷</p>\n<p>##5.消息广播</p>\n<h1 id=\"二、消息协议\"><a href=\"#二、消息协议\" class=\"headerlink\" title=\"二、消息协议\"></a>二、消息协议</h1><h2 id=\"1、JMS\"><a href=\"#1、JMS\" class=\"headerlink\" title=\"1、JMS\"></a>1、JMS</h2><p>基于JVM消息代理的规范。</p>\n<h2 id=\"2、AMQP\"><a href=\"#2、AMQP\" class=\"headerlink\" title=\"2、AMQP\"></a>2、AMQP</h2><p>高级消息队列协议，也是一个消息代理的规范，兼容JMS</p>\n<h2 id=\"比较：\"><a href=\"#比较：\" class=\"headerlink\" title=\"比较：\"></a>比较：</h2><p>JMS:仅支持java，不跨语言</p>\n<p>AMQP:跨语言</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>定义</th>\n<th>跨平台，跨语言</th>\n<th>Model</th>\n<th></th>\n<th>实现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JMS</td>\n<td>java api</td>\n<td>否</td>\n<td>(1)P2P<br>(2)Pub/sub</td>\n<td></td>\n<td>ActiveMQ，HornetMQ</td>\n</tr>\n<tr>\n<td>AMQP</td>\n<td>网络级协议，兼容JMS</td>\n<td>是</td>\n<td>五种</td>\n<td></td>\n<td>RabbitMQ</td>\n</tr>\n</tbody></table>\n<h1 id=\"三、常用的消息队列\"><a href=\"#三、常用的消息队列\" class=\"headerlink\" title=\"三、常用的消息队列\"></a>三、常用的消息队列</h1><p>##1、RabbitMQ</p>\n<p>###1、特点</p>\n<p>使用erlang（交换机领域使用的语言），数据延迟低</p>\n<p>有较低概率丢失消息</p>\n<p>实现了AMQP</p>\n<p>10w+ QPS</p>\n<p>开源、性能优秀，稳定性保障</p>\n<p>集群模式丰富，表达式配置，HA模式，镜像队列模型</p>\n<p>###2、核心概念</p>\n<p>#####Message:</p>\n<p>#####Virtual Host:</p>\n<p>#####Publisher</p>\n<h5 id=\"Exchange\"><a href=\"#Exchange\" class=\"headerlink\" title=\"Exchange\"></a>Exchange</h5><h5 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue:\"></a>Queue:</h5><h5 id=\"Binding\"><a href=\"#Binding\" class=\"headerlink\" title=\"Binding\"></a>Binding</h5><h5 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h5><h5 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h5><h5 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h5><p>#####Broker</p>\n<p>###3、Exchange类型</p>\n<h4 id=\"direct-按照键值匹配\"><a href=\"#direct-按照键值匹配\" class=\"headerlink\" title=\"direct:按照键值匹配\"></a>direct:按照键值匹配</h4><p><img src=\"images/exchange-direct.png\" alt></p>\n<h4 id=\"fanout\"><a href=\"#fanout\" class=\"headerlink\" title=\"fanout\"></a>fanout</h4><p><img src=\"images/exchange-fanout.png\" alt></p>\n<h4 id=\"topic\"><a href=\"#topic\" class=\"headerlink\" title=\"topic\"></a>topic</h4><h4 id=\"headers\"><a href=\"#headers\" class=\"headerlink\" title=\"headers\"></a>headers</h4><h2 id=\"2、ActiveMQ\"><a href=\"#2、ActiveMQ\" class=\"headerlink\" title=\"2、ActiveMQ\"></a>2、ActiveMQ</h2><h2 id=\"3、RocketMQ\"><a href=\"#3、RocketMQ\" class=\"headerlink\" title=\"3、RocketMQ\"></a>3、RocketMQ</h2><h2 id=\"4、Kafka\"><a href=\"#4、Kafka\" class=\"headerlink\" title=\"4、Kafka\"></a>4、Kafka</h2><h2 id=\"比较：-1\"><a href=\"#比较：-1\" class=\"headerlink\" title=\"比较：\"></a>比较：</h2><table>\n<thead>\n<tr>\n<th>消息队列\\特性</th>\n<th>单机吞吐量(QPS)</th>\n<th>topic 数量对吞吐量的影响</th>\n<th>时效性</th>\n<th>可用性</th>\n<th>消息可靠性</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ActiveMQ</td>\n<td>1w+，比RocketMQ、Kafka低一个数量级</td>\n<td></td>\n<td></td>\n<td>高，基于主从架构实现高可用</td>\n<td><strong>有较低的概率丢失数据</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>RabbitMQ</td>\n<td>1w+</td>\n<td></td>\n<td></td>\n<td>高，基于主从架构实现高可用</td>\n<td>基本不丢</td>\n<td></td>\n</tr>\n<tr>\n<td>RocketMQ</td>\n<td>10w+,支持高吞吐</td>\n<td></td>\n<td></td>\n<td>非常高，分布式架构</td>\n<td>经过参数优化配置，可以做到0丢失</td>\n<td></td>\n</tr>\n<tr>\n<td>Kafka</td>\n<td>10w+,支持高吞吐，一般配合大数据类的系统进行实时数据计算、日志采集等场景</td>\n<td></td>\n<td></td>\n<td>非常高，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>\n<td>经过参数优化配置，可以做到0丢失</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>#四、面试题</p>\n<p>1.为什么使用消息队列？</p>\n<p>2.消息队列有什么优点和缺点？</p>\n<p>3.kafka、activeMQ、rabbitMQ,rocketMQ都有什么优点和缺点，以及适合哪些场景？</p>\n<h1 id=\"五、你系统的中的使用场景？\"><a href=\"#五、你系统的中的使用场景？\" class=\"headerlink\" title=\"五、你系统的中的使用场景？\"></a>五、你系统的中的使用场景？</h1><p>发送注册邮件</p>\n<p>发送注册短信</p>\n<h1 id=\"六、消息服务中的概念\"><a href=\"#六、消息服务中的概念\" class=\"headerlink\" title=\"六、消息服务中的概念\"></a>六、消息服务中的概念</h1><h2 id=\"1、消息代理（message-broker）\"><a href=\"#1、消息代理（message-broker）\" class=\"headerlink\" title=\"1、消息代理（message broker）\"></a>1、消息代理（message broker）</h2><h2 id=\"2、目的地（destination）\"><a href=\"#2、目的地（destination）\" class=\"headerlink\" title=\"2、目的地（destination）\"></a>2、目的地（destination）</h2><p>当消息发送者发送消息以后，将有消息代理接管，消息代理保证消息传递到指定目的地。</p>\n<p>目的地有两种形式：</p>\n<p>1）.队列（queue）：点对点消息通信</p>\n<p>2）.主题（topic）：发布/订阅</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、使用场景（解耦、异步、削峰）\"><a href=\"#一、使用场景（解耦、异步、削峰）\" class=\"headerlink\" title=\"一、使用场景（解耦、异步、削峰）\"></a>一、使用场景（解耦、异步、削峰）</h1><p>##1.应用解耦合</p>\n<p>不使用消息队列：</p>\n<p><img src=\"images/mq-1.png\" alt></p>\n<p>##2.服务通信</p>\n<p>##3.异步任务</p>\n<p>##4.削峰填谷</p>\n<p>##5.消息广播</p>\n<h1 id=\"二、消息协议\"><a href=\"#二、消息协议\" class=\"headerlink\" title=\"二、消息协议\"></a>二、消息协议</h1><h2 id=\"1、JMS\"><a href=\"#1、JMS\" class=\"headerlink\" title=\"1、JMS\"></a>1、JMS</h2><p>基于JVM消息代理的规范。</p>\n<h2 id=\"2、AMQP\"><a href=\"#2、AMQP\" class=\"headerlink\" title=\"2、AMQP\"></a>2、AMQP</h2><p>高级消息队列协议，也是一个消息代理的规范，兼容JMS</p>\n<h2 id=\"比较：\"><a href=\"#比较：\" class=\"headerlink\" title=\"比较：\"></a>比较：</h2><p>JMS:仅支持java，不跨语言</p>\n<p>AMQP:跨语言</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>定义</th>\n<th>跨平台，跨语言</th>\n<th>Model</th>\n<th></th>\n<th>实现</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>JMS</td>\n<td>java api</td>\n<td>否</td>\n<td>(1)P2P<br>(2)Pub/sub</td>\n<td></td>\n<td>ActiveMQ，HornetMQ</td>\n</tr>\n<tr>\n<td>AMQP</td>\n<td>网络级协议，兼容JMS</td>\n<td>是</td>\n<td>五种</td>\n<td></td>\n<td>RabbitMQ</td>\n</tr>\n</tbody></table>\n<h1 id=\"三、常用的消息队列\"><a href=\"#三、常用的消息队列\" class=\"headerlink\" title=\"三、常用的消息队列\"></a>三、常用的消息队列</h1><p>##1、RabbitMQ</p>\n<p>###1、特点</p>\n<p>使用erlang（交换机领域使用的语言），数据延迟低</p>\n<p>有较低概率丢失消息</p>\n<p>实现了AMQP</p>\n<p>10w+ QPS</p>\n<p>开源、性能优秀，稳定性保障</p>\n<p>集群模式丰富，表达式配置，HA模式，镜像队列模型</p>\n<p>###2、核心概念</p>\n<p>#####Message:</p>\n<p>#####Virtual Host:</p>\n<p>#####Publisher</p>\n<h5 id=\"Exchange\"><a href=\"#Exchange\" class=\"headerlink\" title=\"Exchange\"></a>Exchange</h5><h5 id=\"Queue\"><a href=\"#Queue\" class=\"headerlink\" title=\"Queue:\"></a>Queue:</h5><h5 id=\"Binding\"><a href=\"#Binding\" class=\"headerlink\" title=\"Binding\"></a>Binding</h5><h5 id=\"Connection\"><a href=\"#Connection\" class=\"headerlink\" title=\"Connection\"></a>Connection</h5><h5 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h5><h5 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h5><p>#####Broker</p>\n<p>###3、Exchange类型</p>\n<h4 id=\"direct-按照键值匹配\"><a href=\"#direct-按照键值匹配\" class=\"headerlink\" title=\"direct:按照键值匹配\"></a>direct:按照键值匹配</h4><p><img src=\"images/exchange-direct.png\" alt></p>\n<h4 id=\"fanout\"><a href=\"#fanout\" class=\"headerlink\" title=\"fanout\"></a>fanout</h4><p><img src=\"images/exchange-fanout.png\" alt></p>\n<h4 id=\"topic\"><a href=\"#topic\" class=\"headerlink\" title=\"topic\"></a>topic</h4><h4 id=\"headers\"><a href=\"#headers\" class=\"headerlink\" title=\"headers\"></a>headers</h4><h2 id=\"2、ActiveMQ\"><a href=\"#2、ActiveMQ\" class=\"headerlink\" title=\"2、ActiveMQ\"></a>2、ActiveMQ</h2><h2 id=\"3、RocketMQ\"><a href=\"#3、RocketMQ\" class=\"headerlink\" title=\"3、RocketMQ\"></a>3、RocketMQ</h2><h2 id=\"4、Kafka\"><a href=\"#4、Kafka\" class=\"headerlink\" title=\"4、Kafka\"></a>4、Kafka</h2><h2 id=\"比较：-1\"><a href=\"#比较：-1\" class=\"headerlink\" title=\"比较：\"></a>比较：</h2><table>\n<thead>\n<tr>\n<th>消息队列\\特性</th>\n<th>单机吞吐量(QPS)</th>\n<th>topic 数量对吞吐量的影响</th>\n<th>时效性</th>\n<th>可用性</th>\n<th>消息可靠性</th>\n<th></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ActiveMQ</td>\n<td>1w+，比RocketMQ、Kafka低一个数量级</td>\n<td></td>\n<td></td>\n<td>高，基于主从架构实现高可用</td>\n<td><strong>有较低的概率丢失数据</strong></td>\n<td></td>\n</tr>\n<tr>\n<td>RabbitMQ</td>\n<td>1w+</td>\n<td></td>\n<td></td>\n<td>高，基于主从架构实现高可用</td>\n<td>基本不丢</td>\n<td></td>\n</tr>\n<tr>\n<td>RocketMQ</td>\n<td>10w+,支持高吞吐</td>\n<td></td>\n<td></td>\n<td>非常高，分布式架构</td>\n<td>经过参数优化配置，可以做到0丢失</td>\n<td></td>\n</tr>\n<tr>\n<td>Kafka</td>\n<td>10w+,支持高吞吐，一般配合大数据类的系统进行实时数据计算、日志采集等场景</td>\n<td></td>\n<td></td>\n<td>非常高，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>\n<td>经过参数优化配置，可以做到0丢失</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>#四、面试题</p>\n<p>1.为什么使用消息队列？</p>\n<p>2.消息队列有什么优点和缺点？</p>\n<p>3.kafka、activeMQ、rabbitMQ,rocketMQ都有什么优点和缺点，以及适合哪些场景？</p>\n<h1 id=\"五、你系统的中的使用场景？\"><a href=\"#五、你系统的中的使用场景？\" class=\"headerlink\" title=\"五、你系统的中的使用场景？\"></a>五、你系统的中的使用场景？</h1><p>发送注册邮件</p>\n<p>发送注册短信</p>\n<h1 id=\"六、消息服务中的概念\"><a href=\"#六、消息服务中的概念\" class=\"headerlink\" title=\"六、消息服务中的概念\"></a>六、消息服务中的概念</h1><h2 id=\"1、消息代理（message-broker）\"><a href=\"#1、消息代理（message-broker）\" class=\"headerlink\" title=\"1、消息代理（message broker）\"></a>1、消息代理（message broker）</h2><h2 id=\"2、目的地（destination）\"><a href=\"#2、目的地（destination）\" class=\"headerlink\" title=\"2、目的地（destination）\"></a>2、目的地（destination）</h2><p>当消息发送者发送消息以后，将有消息代理接管，消息代理保证消息传递到指定目的地。</p>\n<p>目的地有两种形式：</p>\n<p>1）.队列（queue）：点对点消息通信</p>\n<p>2）.主题（topic）：发布/订阅</p>\n"},{"title":"redis的数据类型","_content":"\n# hash\n## 特点\n\n## 重要API\n* hget,时间复杂度O(1)\n\t* hget key field ：获取hash key对应的field的value\n\n* hset,时间复杂度O(1)\n\t* hset key field value  ：设置hash key对应的field的value\n\n* hdel,时间复杂度O(1)\n\t* hdel key field ：删除hash key对应的field的value\n\t\n\t","source":"_posts/缓存/数据类型.md","raw":"---\ntitle: redis的数据类型\ntags: \n- 缓存\ncategories:\n- 缓存\n---\n\n# hash\n## 特点\n\n## 重要API\n* hget,时间复杂度O(1)\n\t* hget key field ：获取hash key对应的field的value\n\n* hset,时间复杂度O(1)\n\t* hset key field value  ：设置hash key对应的field的value\n\n* hdel,时间复杂度O(1)\n\t* hdel key field ：删除hash key对应的field的value\n\t\n\t","slug":"缓存/数据类型","published":1,"date":"2019-09-12T13:26:46.286Z","updated":"2019-11-25T14:00:35.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5jt001hlcvd29noji9u","content":"<h1 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h1><h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><h2 id=\"重要API\"><a href=\"#重要API\" class=\"headerlink\" title=\"重要API\"></a>重要API</h2><ul>\n<li><p>hget,时间复杂度O(1)</p>\n<ul>\n<li>hget key field ：获取hash key对应的field的value</li>\n</ul>\n</li>\n<li><p>hset,时间复杂度O(1)</p>\n<ul>\n<li>hset key field value  ：设置hash key对应的field的value</li>\n</ul>\n</li>\n<li><p>hdel,时间复杂度O(1)</p>\n<ul>\n<li>hdel key field ：删除hash key对应的field的value</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h1><h2 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h2><h2 id=\"重要API\"><a href=\"#重要API\" class=\"headerlink\" title=\"重要API\"></a>重要API</h2><ul>\n<li><p>hget,时间复杂度O(1)</p>\n<ul>\n<li>hget key field ：获取hash key对应的field的value</li>\n</ul>\n</li>\n<li><p>hset,时间复杂度O(1)</p>\n<ul>\n<li>hset key field value  ：设置hash key对应的field的value</li>\n</ul>\n</li>\n<li><p>hdel,时间复杂度O(1)</p>\n<ul>\n<li>hdel key field ：删除hash key对应的field的value</li>\n</ul>\n</li>\n</ul>\n"},{"title":"网络基础","date":"2019-09-11T16:00:00.000Z","_content":"\n\n","source":"_posts/网络/网络基础.md","raw":"---\ntitle: 网络基础\ndate: 2019-9-12\ntags: \n- 网络基础\ncategories:\n- 网络\n---\n\n\n","slug":"网络/网络基础","published":1,"updated":"2019-10-11T11:55:53.448Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5jv001jlcvdld8bdgng","content":"","site":{"data":{}},"excerpt":"","more":""},{"_content":"\n本来是有两轮，第一轮结对编程，第二轮常规面试，结果第一轮就挂了。\n给出的原因：\n1.快捷键不熟悉：这个也是醉了，用笔记本在eclipse中Ctrl+Alt+R敲错了两次，本来要自带键盘的，最后没带\n2.写代码复制粘贴太多：让重构方法，也就在原来的基础上做的修改，没想到这个也是原因\n3.java基础不扎实：主要是下面两个低级错误导致，以后不能再犯了\n * 1.写单例模式时候没有一次性写出来，被面试官打断，让把方法改成static；问为什么不用static，给很随意的说了一下不想使用静态，结果最后一想，单例的变量也是使用的静态，\n * 2.接口和抽象类的使用场景？这个答的不好\n\n\n两个面试官，一男，一女，刚进去的时候就看到男的给女的说，上次是我，这次你来吧，让女的做主导\n直接让讲一下代码逻辑，可以优化的地方，重构自己的代码，其他也没问高深的问题\n\n\n总结：\n1.基础太重要，面试前一定要把基础的面试题搞清楚，弄明白\n2.一定要想清楚再说，不能随口说，很容易出现错误，被面试官追问；面试官的问题是基础的问题，但是一下子答不上来，可以给说组织一下语言，不能说错","source":"_posts/面试/Thoughtworks面试经历.md","raw":"\n本来是有两轮，第一轮结对编程，第二轮常规面试，结果第一轮就挂了。\n给出的原因：\n1.快捷键不熟悉：这个也是醉了，用笔记本在eclipse中Ctrl+Alt+R敲错了两次，本来要自带键盘的，最后没带\n2.写代码复制粘贴太多：让重构方法，也就在原来的基础上做的修改，没想到这个也是原因\n3.java基础不扎实：主要是下面两个低级错误导致，以后不能再犯了\n * 1.写单例模式时候没有一次性写出来，被面试官打断，让把方法改成static；问为什么不用static，给很随意的说了一下不想使用静态，结果最后一想，单例的变量也是使用的静态，\n * 2.接口和抽象类的使用场景？这个答的不好\n\n\n两个面试官，一男，一女，刚进去的时候就看到男的给女的说，上次是我，这次你来吧，让女的做主导\n直接让讲一下代码逻辑，可以优化的地方，重构自己的代码，其他也没问高深的问题\n\n\n总结：\n1.基础太重要，面试前一定要把基础的面试题搞清楚，弄明白\n2.一定要想清楚再说，不能随口说，很容易出现错误，被面试官追问；面试官的问题是基础的问题，但是一下子答不上来，可以给说组织一下语言，不能说错","slug":"面试/Thoughtworks面试经历","published":1,"date":"2019-11-04T10:40:53.680Z","updated":"2019-11-26T12:10:36.750Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5jy001mlcvdfywuube3","content":"<p>本来是有两轮，第一轮结对编程，第二轮常规面试，结果第一轮就挂了。<br>给出的原因：<br>1.快捷键不熟悉：这个也是醉了，用笔记本在eclipse中Ctrl+Alt+R敲错了两次，本来要自带键盘的，最后没带<br>2.写代码复制粘贴太多：让重构方法，也就在原来的基础上做的修改，没想到这个也是原因<br>3.java基础不扎实：主要是下面两个低级错误导致，以后不能再犯了</p>\n<ul>\n<li>1.写单例模式时候没有一次性写出来，被面试官打断，让把方法改成static；问为什么不用static，给很随意的说了一下不想使用静态，结果最后一想，单例的变量也是使用的静态，</li>\n<li>2.接口和抽象类的使用场景？这个答的不好</li>\n</ul>\n<p>两个面试官，一男，一女，刚进去的时候就看到男的给女的说，上次是我，这次你来吧，让女的做主导<br>直接让讲一下代码逻辑，可以优化的地方，重构自己的代码，其他也没问高深的问题</p>\n<p>总结：<br>1.基础太重要，面试前一定要把基础的面试题搞清楚，弄明白<br>2.一定要想清楚再说，不能随口说，很容易出现错误，被面试官追问；面试官的问题是基础的问题，但是一下子答不上来，可以给说组织一下语言，不能说错</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本来是有两轮，第一轮结对编程，第二轮常规面试，结果第一轮就挂了。<br>给出的原因：<br>1.快捷键不熟悉：这个也是醉了，用笔记本在eclipse中Ctrl+Alt+R敲错了两次，本来要自带键盘的，最后没带<br>2.写代码复制粘贴太多：让重构方法，也就在原来的基础上做的修改，没想到这个也是原因<br>3.java基础不扎实：主要是下面两个低级错误导致，以后不能再犯了</p>\n<ul>\n<li>1.写单例模式时候没有一次性写出来，被面试官打断，让把方法改成static；问为什么不用static，给很随意的说了一下不想使用静态，结果最后一想，单例的变量也是使用的静态，</li>\n<li>2.接口和抽象类的使用场景？这个答的不好</li>\n</ul>\n<p>两个面试官，一男，一女，刚进去的时候就看到男的给女的说，上次是我，这次你来吧，让女的做主导<br>直接让讲一下代码逻辑，可以优化的地方，重构自己的代码，其他也没问高深的问题</p>\n<p>总结：<br>1.基础太重要，面试前一定要把基础的面试题搞清楚，弄明白<br>2.一定要想清楚再说，不能随口说，很容易出现错误，被面试官追问；面试官的问题是基础的问题，但是一下子答不上来，可以给说组织一下语言，不能说错</p>\n"},{"title":"缓存","_content":"\n# 一、缓存类型\n\n## 1、本地缓存\n\n###1）、实现方式：\n\nLRUMap(apache工具类)\n\nEhcache\n\n### 2）、优点\n\n内存缓存，没有远程交互开销\n\n### 3）、缺点\n\n容量较小，无法扩展\n\n## 2、分布式缓存\n\n\n\n## 3、多级缓存\n\n# 二、淘汰策略\n\n## 1、FIFO\n\n淘汰最早的数据\n\n## 2、LRU：least recently used\n\n最近最少使用\n\n## 3、LFU\n\n淘汰最近使用频率最低的数据\n\n# 三、缓存问题\n\n## 1、缓存不一致\n\n## 2、缓存更新\n\n## 3、缓存击穿（缓存穿透）\n\n缓存里面没有要找的数据，去数据库里面查找\n\n## 4、缓存雪崩\n\n| 缓存问题   | 产生原因        | 解决方案                |\n| ------ | ----------- | ------------------- |\n| 缓存更新方式 | 数据变更、缓存时效性  | 同步更新、失效更新、异步更新、定时更新 |\n| 缓存不一致  | 同步更新失败、异步更新 | 增加重试、补偿任务、最终一致      |\n| 缓存穿透   | 恶意攻击        | 空对象缓存、blomfilter过滤器 |\n| 缓存击穿   | 热点key失效     | 互斥更新、随机退避、差异失效时间    |\n| 缓存雪崩   | 缓存挂掉        | 快速失败熔断、主从模式、集群模式    |\n\n\n\n# 四、Redis\n\n## 1、数据类型\n\n## 2、功能\n\n### 1）、bitmap\n\n\t### 2）、hyperLogLog\n\n### 3)、geospatial\n\n### 4)、pub/sub\n\n### 5)、pipeline\n\n### 6）、事务\n\n### 7）、lua脚本\n\n\n\n## 3、数据持久化\n\n### 1）、AOF\n\n二进制\n\n### 2)、RDB\n\n文本记录\n\n## 4、淘汰策略\n\n# 面试题\n\n## 1、Redis和Memcache有什么区别？该如何选用？\n\n|      | Redis   | Memcache |\n| ---- | ------- | -------- |\n| 数据类型 | 五种数据类型  | 只有一种     |\n| 持久化  | RDB,AOF | 不支持      |\n| 主从支持 |         | 不支持主从结构  |\n| 分片支持 |         | 不支持分片    |\n|      |         |          |\n\n## 2、你用过哪些Redis的数据结构？用在什么场景下？\n\n首先要知道五种数据类型:string,list,set,zset,hash;\n\n|        | 场景       |\n| ------ | -------- |\n| string | 分布式锁，计数器 |\n| hash   | 对象       |\n| list   | 链表       |\n| set    | 集合，去重    |\n| zset   | 排行榜      |\n\n## 3、Redis有哪些持久化方式？区别是什么？\n\n|      | RDB                   | AOF             |\n| ---- | --------------------- | --------------- |\n| 效率   | 全库保存，效率较低，二进制格式，读写速度快 | 文本保存命令，执行效率低，灵活 |\n| 数据丢失 | 丢失数据多                 | 少量的丢失           |\n|      |                       |                 |\n|      |                       |                 |\n|      |                       |                 |\n\n# 4、Redis的过期机制是怎么样的？Redis有哪些淘汰策略？\n\n## 5、如何保证Redis的高并发和高可用？\n\n高可用：sentinel\n\n高并发：\n\n## 6、如何使用Redis实现延迟队列？（异步队列）\n\n使用sortedset做延迟队列，使用时间戳\n\n使用list作为队列，rpush入队，生成消息，lpop出队，消费消息\n\n使用pub/sub，实现一对多的队列\n\n## 7、如何使用Redis实现分布式锁？\n\n\n\n## 8、为什么Redis能这么快？（10w+ QPS）\n\n1)、纯内存的数据库\n\n**2）、单进程单线程，避免线程切换开销**\n\n3）、数据类型简单\n\n4）、使用多路IO服用模型，非阻塞IO","source":"_posts/缓存/缓存.md","raw":"---\ntitle: 缓存\ntags: \n- 缓存\ncategories:\n- 缓存\n---\n\n# 一、缓存类型\n\n## 1、本地缓存\n\n###1）、实现方式：\n\nLRUMap(apache工具类)\n\nEhcache\n\n### 2）、优点\n\n内存缓存，没有远程交互开销\n\n### 3）、缺点\n\n容量较小，无法扩展\n\n## 2、分布式缓存\n\n\n\n## 3、多级缓存\n\n# 二、淘汰策略\n\n## 1、FIFO\n\n淘汰最早的数据\n\n## 2、LRU：least recently used\n\n最近最少使用\n\n## 3、LFU\n\n淘汰最近使用频率最低的数据\n\n# 三、缓存问题\n\n## 1、缓存不一致\n\n## 2、缓存更新\n\n## 3、缓存击穿（缓存穿透）\n\n缓存里面没有要找的数据，去数据库里面查找\n\n## 4、缓存雪崩\n\n| 缓存问题   | 产生原因        | 解决方案                |\n| ------ | ----------- | ------------------- |\n| 缓存更新方式 | 数据变更、缓存时效性  | 同步更新、失效更新、异步更新、定时更新 |\n| 缓存不一致  | 同步更新失败、异步更新 | 增加重试、补偿任务、最终一致      |\n| 缓存穿透   | 恶意攻击        | 空对象缓存、blomfilter过滤器 |\n| 缓存击穿   | 热点key失效     | 互斥更新、随机退避、差异失效时间    |\n| 缓存雪崩   | 缓存挂掉        | 快速失败熔断、主从模式、集群模式    |\n\n\n\n# 四、Redis\n\n## 1、数据类型\n\n## 2、功能\n\n### 1）、bitmap\n\n\t### 2）、hyperLogLog\n\n### 3)、geospatial\n\n### 4)、pub/sub\n\n### 5)、pipeline\n\n### 6）、事务\n\n### 7）、lua脚本\n\n\n\n## 3、数据持久化\n\n### 1）、AOF\n\n二进制\n\n### 2)、RDB\n\n文本记录\n\n## 4、淘汰策略\n\n# 面试题\n\n## 1、Redis和Memcache有什么区别？该如何选用？\n\n|      | Redis   | Memcache |\n| ---- | ------- | -------- |\n| 数据类型 | 五种数据类型  | 只有一种     |\n| 持久化  | RDB,AOF | 不支持      |\n| 主从支持 |         | 不支持主从结构  |\n| 分片支持 |         | 不支持分片    |\n|      |         |          |\n\n## 2、你用过哪些Redis的数据结构？用在什么场景下？\n\n首先要知道五种数据类型:string,list,set,zset,hash;\n\n|        | 场景       |\n| ------ | -------- |\n| string | 分布式锁，计数器 |\n| hash   | 对象       |\n| list   | 链表       |\n| set    | 集合，去重    |\n| zset   | 排行榜      |\n\n## 3、Redis有哪些持久化方式？区别是什么？\n\n|      | RDB                   | AOF             |\n| ---- | --------------------- | --------------- |\n| 效率   | 全库保存，效率较低，二进制格式，读写速度快 | 文本保存命令，执行效率低，灵活 |\n| 数据丢失 | 丢失数据多                 | 少量的丢失           |\n|      |                       |                 |\n|      |                       |                 |\n|      |                       |                 |\n\n# 4、Redis的过期机制是怎么样的？Redis有哪些淘汰策略？\n\n## 5、如何保证Redis的高并发和高可用？\n\n高可用：sentinel\n\n高并发：\n\n## 6、如何使用Redis实现延迟队列？（异步队列）\n\n使用sortedset做延迟队列，使用时间戳\n\n使用list作为队列，rpush入队，生成消息，lpop出队，消费消息\n\n使用pub/sub，实现一对多的队列\n\n## 7、如何使用Redis实现分布式锁？\n\n\n\n## 8、为什么Redis能这么快？（10w+ QPS）\n\n1)、纯内存的数据库\n\n**2）、单进程单线程，避免线程切换开销**\n\n3）、数据类型简单\n\n4）、使用多路IO服用模型，非阻塞IO","slug":"缓存/缓存","published":1,"date":"2019-11-25T13:15:03.921Z","updated":"2019-11-26T12:09:44.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5k0001plcvda7ubdj7w","content":"<h1 id=\"一、缓存类型\"><a href=\"#一、缓存类型\" class=\"headerlink\" title=\"一、缓存类型\"></a>一、缓存类型</h1><h2 id=\"1、本地缓存\"><a href=\"#1、本地缓存\" class=\"headerlink\" title=\"1、本地缓存\"></a>1、本地缓存</h2><p>###1）、实现方式：</p>\n<p>LRUMap(apache工具类)</p>\n<p>Ehcache</p>\n<h3 id=\"2）、优点\"><a href=\"#2）、优点\" class=\"headerlink\" title=\"2）、优点\"></a>2）、优点</h3><p>内存缓存，没有远程交互开销</p>\n<h3 id=\"3）、缺点\"><a href=\"#3）、缺点\" class=\"headerlink\" title=\"3）、缺点\"></a>3）、缺点</h3><p>容量较小，无法扩展</p>\n<h2 id=\"2、分布式缓存\"><a href=\"#2、分布式缓存\" class=\"headerlink\" title=\"2、分布式缓存\"></a>2、分布式缓存</h2><h2 id=\"3、多级缓存\"><a href=\"#3、多级缓存\" class=\"headerlink\" title=\"3、多级缓存\"></a>3、多级缓存</h2><h1 id=\"二、淘汰策略\"><a href=\"#二、淘汰策略\" class=\"headerlink\" title=\"二、淘汰策略\"></a>二、淘汰策略</h1><h2 id=\"1、FIFO\"><a href=\"#1、FIFO\" class=\"headerlink\" title=\"1、FIFO\"></a>1、FIFO</h2><p>淘汰最早的数据</p>\n<h2 id=\"2、LRU：least-recently-used\"><a href=\"#2、LRU：least-recently-used\" class=\"headerlink\" title=\"2、LRU：least recently used\"></a>2、LRU：least recently used</h2><p>最近最少使用</p>\n<h2 id=\"3、LFU\"><a href=\"#3、LFU\" class=\"headerlink\" title=\"3、LFU\"></a>3、LFU</h2><p>淘汰最近使用频率最低的数据</p>\n<h1 id=\"三、缓存问题\"><a href=\"#三、缓存问题\" class=\"headerlink\" title=\"三、缓存问题\"></a>三、缓存问题</h1><h2 id=\"1、缓存不一致\"><a href=\"#1、缓存不一致\" class=\"headerlink\" title=\"1、缓存不一致\"></a>1、缓存不一致</h2><h2 id=\"2、缓存更新\"><a href=\"#2、缓存更新\" class=\"headerlink\" title=\"2、缓存更新\"></a>2、缓存更新</h2><h2 id=\"3、缓存击穿（缓存穿透）\"><a href=\"#3、缓存击穿（缓存穿透）\" class=\"headerlink\" title=\"3、缓存击穿（缓存穿透）\"></a>3、缓存击穿（缓存穿透）</h2><p>缓存里面没有要找的数据，去数据库里面查找</p>\n<h2 id=\"4、缓存雪崩\"><a href=\"#4、缓存雪崩\" class=\"headerlink\" title=\"4、缓存雪崩\"></a>4、缓存雪崩</h2><table>\n<thead>\n<tr>\n<th>缓存问题</th>\n<th>产生原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>缓存更新方式</td>\n<td>数据变更、缓存时效性</td>\n<td>同步更新、失效更新、异步更新、定时更新</td>\n</tr>\n<tr>\n<td>缓存不一致</td>\n<td>同步更新失败、异步更新</td>\n<td>增加重试、补偿任务、最终一致</td>\n</tr>\n<tr>\n<td>缓存穿透</td>\n<td>恶意攻击</td>\n<td>空对象缓存、blomfilter过滤器</td>\n</tr>\n<tr>\n<td>缓存击穿</td>\n<td>热点key失效</td>\n<td>互斥更新、随机退避、差异失效时间</td>\n</tr>\n<tr>\n<td>缓存雪崩</td>\n<td>缓存挂掉</td>\n<td>快速失败熔断、主从模式、集群模式</td>\n</tr>\n</tbody></table>\n<h1 id=\"四、Redis\"><a href=\"#四、Redis\" class=\"headerlink\" title=\"四、Redis\"></a>四、Redis</h1><h2 id=\"1、数据类型\"><a href=\"#1、数据类型\" class=\"headerlink\" title=\"1、数据类型\"></a>1、数据类型</h2><h2 id=\"2、功能\"><a href=\"#2、功能\" class=\"headerlink\" title=\"2、功能\"></a>2、功能</h2><h3 id=\"1）、bitmap\"><a href=\"#1）、bitmap\" class=\"headerlink\" title=\"1）、bitmap\"></a>1）、bitmap</h3><pre><code>### 2）、hyperLogLog</code></pre><h3 id=\"3-、geospatial\"><a href=\"#3-、geospatial\" class=\"headerlink\" title=\"3)、geospatial\"></a>3)、geospatial</h3><h3 id=\"4-、pub-sub\"><a href=\"#4-、pub-sub\" class=\"headerlink\" title=\"4)、pub/sub\"></a>4)、pub/sub</h3><h3 id=\"5-、pipeline\"><a href=\"#5-、pipeline\" class=\"headerlink\" title=\"5)、pipeline\"></a>5)、pipeline</h3><h3 id=\"6）、事务\"><a href=\"#6）、事务\" class=\"headerlink\" title=\"6）、事务\"></a>6）、事务</h3><h3 id=\"7）、lua脚本\"><a href=\"#7）、lua脚本\" class=\"headerlink\" title=\"7）、lua脚本\"></a>7）、lua脚本</h3><h2 id=\"3、数据持久化\"><a href=\"#3、数据持久化\" class=\"headerlink\" title=\"3、数据持久化\"></a>3、数据持久化</h2><h3 id=\"1）、AOF\"><a href=\"#1）、AOF\" class=\"headerlink\" title=\"1）、AOF\"></a>1）、AOF</h3><p>二进制</p>\n<h3 id=\"2-、RDB\"><a href=\"#2-、RDB\" class=\"headerlink\" title=\"2)、RDB\"></a>2)、RDB</h3><p>文本记录</p>\n<h2 id=\"4、淘汰策略\"><a href=\"#4、淘汰策略\" class=\"headerlink\" title=\"4、淘汰策略\"></a>4、淘汰策略</h2><h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"1、Redis和Memcache有什么区别？该如何选用？\"><a href=\"#1、Redis和Memcache有什么区别？该如何选用？\" class=\"headerlink\" title=\"1、Redis和Memcache有什么区别？该如何选用？\"></a>1、Redis和Memcache有什么区别？该如何选用？</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>Redis</th>\n<th>Memcache</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据类型</td>\n<td>五种数据类型</td>\n<td>只有一种</td>\n</tr>\n<tr>\n<td>持久化</td>\n<td>RDB,AOF</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>主从支持</td>\n<td></td>\n<td>不支持主从结构</td>\n</tr>\n<tr>\n<td>分片支持</td>\n<td></td>\n<td>不支持分片</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"2、你用过哪些Redis的数据结构？用在什么场景下？\"><a href=\"#2、你用过哪些Redis的数据结构？用在什么场景下？\" class=\"headerlink\" title=\"2、你用过哪些Redis的数据结构？用在什么场景下？\"></a>2、你用过哪些Redis的数据结构？用在什么场景下？</h2><p>首先要知道五种数据类型:string,list,set,zset,hash;</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td>分布式锁，计数器</td>\n</tr>\n<tr>\n<td>hash</td>\n<td>对象</td>\n</tr>\n<tr>\n<td>list</td>\n<td>链表</td>\n</tr>\n<tr>\n<td>set</td>\n<td>集合，去重</td>\n</tr>\n<tr>\n<td>zset</td>\n<td>排行榜</td>\n</tr>\n</tbody></table>\n<h2 id=\"3、Redis有哪些持久化方式？区别是什么？\"><a href=\"#3、Redis有哪些持久化方式？区别是什么？\" class=\"headerlink\" title=\"3、Redis有哪些持久化方式？区别是什么？\"></a>3、Redis有哪些持久化方式？区别是什么？</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>RDB</th>\n<th>AOF</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>效率</td>\n<td>全库保存，效率较低，二进制格式，读写速度快</td>\n<td>文本保存命令，执行效率低，灵活</td>\n</tr>\n<tr>\n<td>数据丢失</td>\n<td>丢失数据多</td>\n<td>少量的丢失</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"4、Redis的过期机制是怎么样的？Redis有哪些淘汰策略？\"><a href=\"#4、Redis的过期机制是怎么样的？Redis有哪些淘汰策略？\" class=\"headerlink\" title=\"4、Redis的过期机制是怎么样的？Redis有哪些淘汰策略？\"></a>4、Redis的过期机制是怎么样的？Redis有哪些淘汰策略？</h1><h2 id=\"5、如何保证Redis的高并发和高可用？\"><a href=\"#5、如何保证Redis的高并发和高可用？\" class=\"headerlink\" title=\"5、如何保证Redis的高并发和高可用？\"></a>5、如何保证Redis的高并发和高可用？</h2><p>高可用：sentinel</p>\n<p>高并发：</p>\n<h2 id=\"6、如何使用Redis实现延迟队列？（异步队列）\"><a href=\"#6、如何使用Redis实现延迟队列？（异步队列）\" class=\"headerlink\" title=\"6、如何使用Redis实现延迟队列？（异步队列）\"></a>6、如何使用Redis实现延迟队列？（异步队列）</h2><p>使用sortedset做延迟队列，使用时间戳</p>\n<p>使用list作为队列，rpush入队，生成消息，lpop出队，消费消息</p>\n<p>使用pub/sub，实现一对多的队列</p>\n<h2 id=\"7、如何使用Redis实现分布式锁？\"><a href=\"#7、如何使用Redis实现分布式锁？\" class=\"headerlink\" title=\"7、如何使用Redis实现分布式锁？\"></a>7、如何使用Redis实现分布式锁？</h2><h2 id=\"8、为什么Redis能这么快？（10w-QPS）\"><a href=\"#8、为什么Redis能这么快？（10w-QPS）\" class=\"headerlink\" title=\"8、为什么Redis能这么快？（10w+ QPS）\"></a>8、为什么Redis能这么快？（10w+ QPS）</h2><p>1)、纯内存的数据库</p>\n<p><strong>2）、单进程单线程，避免线程切换开销</strong></p>\n<p>3）、数据类型简单</p>\n<p>4）、使用多路IO服用模型，非阻塞IO</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"一、缓存类型\"><a href=\"#一、缓存类型\" class=\"headerlink\" title=\"一、缓存类型\"></a>一、缓存类型</h1><h2 id=\"1、本地缓存\"><a href=\"#1、本地缓存\" class=\"headerlink\" title=\"1、本地缓存\"></a>1、本地缓存</h2><p>###1）、实现方式：</p>\n<p>LRUMap(apache工具类)</p>\n<p>Ehcache</p>\n<h3 id=\"2）、优点\"><a href=\"#2）、优点\" class=\"headerlink\" title=\"2）、优点\"></a>2）、优点</h3><p>内存缓存，没有远程交互开销</p>\n<h3 id=\"3）、缺点\"><a href=\"#3）、缺点\" class=\"headerlink\" title=\"3）、缺点\"></a>3）、缺点</h3><p>容量较小，无法扩展</p>\n<h2 id=\"2、分布式缓存\"><a href=\"#2、分布式缓存\" class=\"headerlink\" title=\"2、分布式缓存\"></a>2、分布式缓存</h2><h2 id=\"3、多级缓存\"><a href=\"#3、多级缓存\" class=\"headerlink\" title=\"3、多级缓存\"></a>3、多级缓存</h2><h1 id=\"二、淘汰策略\"><a href=\"#二、淘汰策略\" class=\"headerlink\" title=\"二、淘汰策略\"></a>二、淘汰策略</h1><h2 id=\"1、FIFO\"><a href=\"#1、FIFO\" class=\"headerlink\" title=\"1、FIFO\"></a>1、FIFO</h2><p>淘汰最早的数据</p>\n<h2 id=\"2、LRU：least-recently-used\"><a href=\"#2、LRU：least-recently-used\" class=\"headerlink\" title=\"2、LRU：least recently used\"></a>2、LRU：least recently used</h2><p>最近最少使用</p>\n<h2 id=\"3、LFU\"><a href=\"#3、LFU\" class=\"headerlink\" title=\"3、LFU\"></a>3、LFU</h2><p>淘汰最近使用频率最低的数据</p>\n<h1 id=\"三、缓存问题\"><a href=\"#三、缓存问题\" class=\"headerlink\" title=\"三、缓存问题\"></a>三、缓存问题</h1><h2 id=\"1、缓存不一致\"><a href=\"#1、缓存不一致\" class=\"headerlink\" title=\"1、缓存不一致\"></a>1、缓存不一致</h2><h2 id=\"2、缓存更新\"><a href=\"#2、缓存更新\" class=\"headerlink\" title=\"2、缓存更新\"></a>2、缓存更新</h2><h2 id=\"3、缓存击穿（缓存穿透）\"><a href=\"#3、缓存击穿（缓存穿透）\" class=\"headerlink\" title=\"3、缓存击穿（缓存穿透）\"></a>3、缓存击穿（缓存穿透）</h2><p>缓存里面没有要找的数据，去数据库里面查找</p>\n<h2 id=\"4、缓存雪崩\"><a href=\"#4、缓存雪崩\" class=\"headerlink\" title=\"4、缓存雪崩\"></a>4、缓存雪崩</h2><table>\n<thead>\n<tr>\n<th>缓存问题</th>\n<th>产生原因</th>\n<th>解决方案</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>缓存更新方式</td>\n<td>数据变更、缓存时效性</td>\n<td>同步更新、失效更新、异步更新、定时更新</td>\n</tr>\n<tr>\n<td>缓存不一致</td>\n<td>同步更新失败、异步更新</td>\n<td>增加重试、补偿任务、最终一致</td>\n</tr>\n<tr>\n<td>缓存穿透</td>\n<td>恶意攻击</td>\n<td>空对象缓存、blomfilter过滤器</td>\n</tr>\n<tr>\n<td>缓存击穿</td>\n<td>热点key失效</td>\n<td>互斥更新、随机退避、差异失效时间</td>\n</tr>\n<tr>\n<td>缓存雪崩</td>\n<td>缓存挂掉</td>\n<td>快速失败熔断、主从模式、集群模式</td>\n</tr>\n</tbody></table>\n<h1 id=\"四、Redis\"><a href=\"#四、Redis\" class=\"headerlink\" title=\"四、Redis\"></a>四、Redis</h1><h2 id=\"1、数据类型\"><a href=\"#1、数据类型\" class=\"headerlink\" title=\"1、数据类型\"></a>1、数据类型</h2><h2 id=\"2、功能\"><a href=\"#2、功能\" class=\"headerlink\" title=\"2、功能\"></a>2、功能</h2><h3 id=\"1）、bitmap\"><a href=\"#1）、bitmap\" class=\"headerlink\" title=\"1）、bitmap\"></a>1）、bitmap</h3><pre><code>### 2）、hyperLogLog</code></pre><h3 id=\"3-、geospatial\"><a href=\"#3-、geospatial\" class=\"headerlink\" title=\"3)、geospatial\"></a>3)、geospatial</h3><h3 id=\"4-、pub-sub\"><a href=\"#4-、pub-sub\" class=\"headerlink\" title=\"4)、pub/sub\"></a>4)、pub/sub</h3><h3 id=\"5-、pipeline\"><a href=\"#5-、pipeline\" class=\"headerlink\" title=\"5)、pipeline\"></a>5)、pipeline</h3><h3 id=\"6）、事务\"><a href=\"#6）、事务\" class=\"headerlink\" title=\"6）、事务\"></a>6）、事务</h3><h3 id=\"7）、lua脚本\"><a href=\"#7）、lua脚本\" class=\"headerlink\" title=\"7）、lua脚本\"></a>7）、lua脚本</h3><h2 id=\"3、数据持久化\"><a href=\"#3、数据持久化\" class=\"headerlink\" title=\"3、数据持久化\"></a>3、数据持久化</h2><h3 id=\"1）、AOF\"><a href=\"#1）、AOF\" class=\"headerlink\" title=\"1）、AOF\"></a>1）、AOF</h3><p>二进制</p>\n<h3 id=\"2-、RDB\"><a href=\"#2-、RDB\" class=\"headerlink\" title=\"2)、RDB\"></a>2)、RDB</h3><p>文本记录</p>\n<h2 id=\"4、淘汰策略\"><a href=\"#4、淘汰策略\" class=\"headerlink\" title=\"4、淘汰策略\"></a>4、淘汰策略</h2><h1 id=\"面试题\"><a href=\"#面试题\" class=\"headerlink\" title=\"面试题\"></a>面试题</h1><h2 id=\"1、Redis和Memcache有什么区别？该如何选用？\"><a href=\"#1、Redis和Memcache有什么区别？该如何选用？\" class=\"headerlink\" title=\"1、Redis和Memcache有什么区别？该如何选用？\"></a>1、Redis和Memcache有什么区别？该如何选用？</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>Redis</th>\n<th>Memcache</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>数据类型</td>\n<td>五种数据类型</td>\n<td>只有一种</td>\n</tr>\n<tr>\n<td>持久化</td>\n<td>RDB,AOF</td>\n<td>不支持</td>\n</tr>\n<tr>\n<td>主从支持</td>\n<td></td>\n<td>不支持主从结构</td>\n</tr>\n<tr>\n<td>分片支持</td>\n<td></td>\n<td>不支持分片</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"2、你用过哪些Redis的数据结构？用在什么场景下？\"><a href=\"#2、你用过哪些Redis的数据结构？用在什么场景下？\" class=\"headerlink\" title=\"2、你用过哪些Redis的数据结构？用在什么场景下？\"></a>2、你用过哪些Redis的数据结构？用在什么场景下？</h2><p>首先要知道五种数据类型:string,list,set,zset,hash;</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>场景</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>string</td>\n<td>分布式锁，计数器</td>\n</tr>\n<tr>\n<td>hash</td>\n<td>对象</td>\n</tr>\n<tr>\n<td>list</td>\n<td>链表</td>\n</tr>\n<tr>\n<td>set</td>\n<td>集合，去重</td>\n</tr>\n<tr>\n<td>zset</td>\n<td>排行榜</td>\n</tr>\n</tbody></table>\n<h2 id=\"3、Redis有哪些持久化方式？区别是什么？\"><a href=\"#3、Redis有哪些持久化方式？区别是什么？\" class=\"headerlink\" title=\"3、Redis有哪些持久化方式？区别是什么？\"></a>3、Redis有哪些持久化方式？区别是什么？</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>RDB</th>\n<th>AOF</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>效率</td>\n<td>全库保存，效率较低，二进制格式，读写速度快</td>\n<td>文本保存命令，执行效率低，灵活</td>\n</tr>\n<tr>\n<td>数据丢失</td>\n<td>丢失数据多</td>\n<td>少量的丢失</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h1 id=\"4、Redis的过期机制是怎么样的？Redis有哪些淘汰策略？\"><a href=\"#4、Redis的过期机制是怎么样的？Redis有哪些淘汰策略？\" class=\"headerlink\" title=\"4、Redis的过期机制是怎么样的？Redis有哪些淘汰策略？\"></a>4、Redis的过期机制是怎么样的？Redis有哪些淘汰策略？</h1><h2 id=\"5、如何保证Redis的高并发和高可用？\"><a href=\"#5、如何保证Redis的高并发和高可用？\" class=\"headerlink\" title=\"5、如何保证Redis的高并发和高可用？\"></a>5、如何保证Redis的高并发和高可用？</h2><p>高可用：sentinel</p>\n<p>高并发：</p>\n<h2 id=\"6、如何使用Redis实现延迟队列？（异步队列）\"><a href=\"#6、如何使用Redis实现延迟队列？（异步队列）\" class=\"headerlink\" title=\"6、如何使用Redis实现延迟队列？（异步队列）\"></a>6、如何使用Redis实现延迟队列？（异步队列）</h2><p>使用sortedset做延迟队列，使用时间戳</p>\n<p>使用list作为队列，rpush入队，生成消息，lpop出队，消费消息</p>\n<p>使用pub/sub，实现一对多的队列</p>\n<h2 id=\"7、如何使用Redis实现分布式锁？\"><a href=\"#7、如何使用Redis实现分布式锁？\" class=\"headerlink\" title=\"7、如何使用Redis实现分布式锁？\"></a>7、如何使用Redis实现分布式锁？</h2><h2 id=\"8、为什么Redis能这么快？（10w-QPS）\"><a href=\"#8、为什么Redis能这么快？（10w-QPS）\" class=\"headerlink\" title=\"8、为什么Redis能这么快？（10w+ QPS）\"></a>8、为什么Redis能这么快？（10w+ QPS）</h2><p>1)、纯内存的数据库</p>\n<p><strong>2）、单进程单线程，避免线程切换开销</strong></p>\n<p>3）、数据类型简单</p>\n<p>4）、使用多路IO服用模型，非阻塞IO</p>\n"},{"title":"spring事务","_content":"\n# 接口\n\t* PlatformTransactionManager\n\t* TransactionDefinition\n\t* TransactionStatus\n# ACID:\n\t* 原子性\n\t* 一致性\n\t* 隔离性\n\t* 持久行\n# 传播行为\n\t* Progation_Required\n\t* Progation_Suppport\n\t* Progation_manatory\n\t* Progation_Required_new\n\t* Progation_not_support\n\t* Progation_never\n\t* Progation_nested :spring特有的\n\t\t* 连接点\n# 隔离级别\n\t* Isolation_NOT_COMMITED\n\t* ISolation_COMMITED\n\t* Isolation_Repeatable_read\n\t* Isolation_Serilizable\n# 并发访问问题：\n\t* 脏读：读到其他事务还没提交的数据，数据被回滚后，引起的问题\n\t* 不可重复读：两次都读取结果不一致，读到的数据被其他事务修改后，再去读取，会不一样\n\t* 幻读：也是两次读取结果不一致，读取到的数据后，其他数据有插入或者删除，再去读取，会不一样\n# 原理：Spring AOP","source":"_posts/spring/transaction.md","raw":"---\ntitle: spring事务\ntags: \n- spring\ncategories:\n- spring\n---\n\n# 接口\n\t* PlatformTransactionManager\n\t* TransactionDefinition\n\t* TransactionStatus\n# ACID:\n\t* 原子性\n\t* 一致性\n\t* 隔离性\n\t* 持久行\n# 传播行为\n\t* Progation_Required\n\t* Progation_Suppport\n\t* Progation_manatory\n\t* Progation_Required_new\n\t* Progation_not_support\n\t* Progation_never\n\t* Progation_nested :spring特有的\n\t\t* 连接点\n# 隔离级别\n\t* Isolation_NOT_COMMITED\n\t* ISolation_COMMITED\n\t* Isolation_Repeatable_read\n\t* Isolation_Serilizable\n# 并发访问问题：\n\t* 脏读：读到其他事务还没提交的数据，数据被回滚后，引起的问题\n\t* 不可重复读：两次都读取结果不一致，读到的数据被其他事务修改后，再去读取，会不一样\n\t* 幻读：也是两次读取结果不一致，读取到的数据后，其他数据有插入或者删除，再去读取，会不一样\n# 原理：Spring AOP","slug":"spring/transaction","published":1,"date":"2019-09-12T13:26:46.303Z","updated":"2019-09-13T01:37:51.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5k3001slcvd93f7ruua","content":"<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><pre><code>* PlatformTransactionManager\n* TransactionDefinition\n* TransactionStatus</code></pre><h1 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID:\"></a>ACID:</h1><pre><code>* 原子性\n* 一致性\n* 隔离性\n* 持久行</code></pre><h1 id=\"传播行为\"><a href=\"#传播行为\" class=\"headerlink\" title=\"传播行为\"></a>传播行为</h1><pre><code>* Progation_Required\n* Progation_Suppport\n* Progation_manatory\n* Progation_Required_new\n* Progation_not_support\n* Progation_never\n* Progation_nested :spring特有的\n    * 连接点</code></pre><h1 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h1><pre><code>* Isolation_NOT_COMMITED\n* ISolation_COMMITED\n* Isolation_Repeatable_read\n* Isolation_Serilizable</code></pre><h1 id=\"并发访问问题：\"><a href=\"#并发访问问题：\" class=\"headerlink\" title=\"并发访问问题：\"></a>并发访问问题：</h1><pre><code>* 脏读：读到其他事务还没提交的数据，数据被回滚后，引起的问题\n* 不可重复读：两次都读取结果不一致，读到的数据被其他事务修改后，再去读取，会不一样\n* 幻读：也是两次读取结果不一致，读取到的数据后，其他数据有插入或者删除，再去读取，会不一样</code></pre><h1 id=\"原理：Spring-AOP\"><a href=\"#原理：Spring-AOP\" class=\"headerlink\" title=\"原理：Spring AOP\"></a>原理：Spring AOP</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><pre><code>* PlatformTransactionManager\n* TransactionDefinition\n* TransactionStatus</code></pre><h1 id=\"ACID\"><a href=\"#ACID\" class=\"headerlink\" title=\"ACID:\"></a>ACID:</h1><pre><code>* 原子性\n* 一致性\n* 隔离性\n* 持久行</code></pre><h1 id=\"传播行为\"><a href=\"#传播行为\" class=\"headerlink\" title=\"传播行为\"></a>传播行为</h1><pre><code>* Progation_Required\n* Progation_Suppport\n* Progation_manatory\n* Progation_Required_new\n* Progation_not_support\n* Progation_never\n* Progation_nested :spring特有的\n    * 连接点</code></pre><h1 id=\"隔离级别\"><a href=\"#隔离级别\" class=\"headerlink\" title=\"隔离级别\"></a>隔离级别</h1><pre><code>* Isolation_NOT_COMMITED\n* ISolation_COMMITED\n* Isolation_Repeatable_read\n* Isolation_Serilizable</code></pre><h1 id=\"并发访问问题：\"><a href=\"#并发访问问题：\" class=\"headerlink\" title=\"并发访问问题：\"></a>并发访问问题：</h1><pre><code>* 脏读：读到其他事务还没提交的数据，数据被回滚后，引起的问题\n* 不可重复读：两次都读取结果不一致，读到的数据被其他事务修改后，再去读取，会不一样\n* 幻读：也是两次读取结果不一致，读取到的数据后，其他数据有插入或者删除，再去读取，会不一样</code></pre><h1 id=\"原理：Spring-AOP\"><a href=\"#原理：Spring-AOP\" class=\"headerlink\" title=\"原理：Spring AOP\"></a>原理：Spring AOP</h1>"},{"title":"框架面试题整理","_content":"\n# Mybatis\n\n## 1、Mybatis和Hibernate的区别？\n\n|      | Mybatis     | Hibernate    |\n| ---- | ----------- | ------------ |\n| ORM  | 半自动         | 全自动          |\n| SQL  | 需要手写sql     | 只需要配置表和实体的映射 |\n| 优点   | 灵活，学习快      | 不需要写sql，跨平台  |\n| 缺点   | 需要写sql，不跨平台 | 不够灵活，学习难度高   |\n|      |             |              |\n|      |             |              |\n\n##2、#{}和${}的区别\n\n## 3、\n\n# Spring\n\n## 1、Spring有哪些模块？\n\n##2、动态代理的实现？Cglib和JDK动态代理的区别？\n\ncglib基于字节码技术，会给被代理类生成子类进行实现，所以不能代理final方法\n\nJDK动态代理只能代理实现了接口的类\n\n## 3、事务的传播行为和隔离级别\n\n传播行为是指？\n\n隔离级别与具体的数据库有关，mysql分为RU,RC,RR,Serializable\n\n## 4、BeanFactory和ApplicationContext的区别?\n\n## 5、BeanFactory和FactoryBean的区别？\n\nBeanFactory：顶层的容器实现，有一些最基本的方法，如getBean等\n\nFactoryBean：Bean的工厂，可以根据参数获取不同类型的Bean\n\n## 6、Bean的生命周期\n\n## 7、Spring如何解决循环依赖？\n\n## 8、Spring配置中的placeholder占位符是如何替换的？有什么方法可以实现自定义的配置替换？\n\n##9、SpringMVC的工作流程\n\n\n\n# SpringBoot\n\n## 1、启动流程\n\n## 2、bootstrap配置文件和application配置文件的区别\n\n## 3、自动配置原理\n\n","source":"_posts/面试/框架面试题整理.md","raw":"---\ntitle: 框架面试题整理\ntags: \n- 框架,面试题\ncategories:\n- 面试\n---\n\n# Mybatis\n\n## 1、Mybatis和Hibernate的区别？\n\n|      | Mybatis     | Hibernate    |\n| ---- | ----------- | ------------ |\n| ORM  | 半自动         | 全自动          |\n| SQL  | 需要手写sql     | 只需要配置表和实体的映射 |\n| 优点   | 灵活，学习快      | 不需要写sql，跨平台  |\n| 缺点   | 需要写sql，不跨平台 | 不够灵活，学习难度高   |\n|      |             |              |\n|      |             |              |\n\n##2、#{}和${}的区别\n\n## 3、\n\n# Spring\n\n## 1、Spring有哪些模块？\n\n##2、动态代理的实现？Cglib和JDK动态代理的区别？\n\ncglib基于字节码技术，会给被代理类生成子类进行实现，所以不能代理final方法\n\nJDK动态代理只能代理实现了接口的类\n\n## 3、事务的传播行为和隔离级别\n\n传播行为是指？\n\n隔离级别与具体的数据库有关，mysql分为RU,RC,RR,Serializable\n\n## 4、BeanFactory和ApplicationContext的区别?\n\n## 5、BeanFactory和FactoryBean的区别？\n\nBeanFactory：顶层的容器实现，有一些最基本的方法，如getBean等\n\nFactoryBean：Bean的工厂，可以根据参数获取不同类型的Bean\n\n## 6、Bean的生命周期\n\n## 7、Spring如何解决循环依赖？\n\n## 8、Spring配置中的placeholder占位符是如何替换的？有什么方法可以实现自定义的配置替换？\n\n##9、SpringMVC的工作流程\n\n\n\n# SpringBoot\n\n## 1、启动流程\n\n## 2、bootstrap配置文件和application配置文件的区别\n\n## 3、自动配置原理\n\n","slug":"面试/框架面试题整理","published":1,"date":"2019-11-26T12:10:56.454Z","updated":"2019-11-26T14:31:00.846Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5k5001ulcvd8r6otijb","content":"<h1 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h1><h2 id=\"1、Mybatis和Hibernate的区别？\"><a href=\"#1、Mybatis和Hibernate的区别？\" class=\"headerlink\" title=\"1、Mybatis和Hibernate的区别？\"></a>1、Mybatis和Hibernate的区别？</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>Mybatis</th>\n<th>Hibernate</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ORM</td>\n<td>半自动</td>\n<td>全自动</td>\n</tr>\n<tr>\n<td>SQL</td>\n<td>需要手写sql</td>\n<td>只需要配置表和实体的映射</td>\n</tr>\n<tr>\n<td>优点</td>\n<td>灵活，学习快</td>\n<td>不需要写sql，跨平台</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>需要写sql，不跨平台</td>\n<td>不够灵活，学习难度高</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>##2、#{}和${}的区别</p>\n<h2 id=\"3、\"><a href=\"#3、\" class=\"headerlink\" title=\"3、\"></a>3、</h2><h1 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h1><h2 id=\"1、Spring有哪些模块？\"><a href=\"#1、Spring有哪些模块？\" class=\"headerlink\" title=\"1、Spring有哪些模块？\"></a>1、Spring有哪些模块？</h2><p>##2、动态代理的实现？Cglib和JDK动态代理的区别？</p>\n<p>cglib基于字节码技术，会给被代理类生成子类进行实现，所以不能代理final方法</p>\n<p>JDK动态代理只能代理实现了接口的类</p>\n<h2 id=\"3、事务的传播行为和隔离级别\"><a href=\"#3、事务的传播行为和隔离级别\" class=\"headerlink\" title=\"3、事务的传播行为和隔离级别\"></a>3、事务的传播行为和隔离级别</h2><p>传播行为是指？</p>\n<p>隔离级别与具体的数据库有关，mysql分为RU,RC,RR,Serializable</p>\n<h2 id=\"4、BeanFactory和ApplicationContext的区别\"><a href=\"#4、BeanFactory和ApplicationContext的区别\" class=\"headerlink\" title=\"4、BeanFactory和ApplicationContext的区别?\"></a>4、BeanFactory和ApplicationContext的区别?</h2><h2 id=\"5、BeanFactory和FactoryBean的区别？\"><a href=\"#5、BeanFactory和FactoryBean的区别？\" class=\"headerlink\" title=\"5、BeanFactory和FactoryBean的区别？\"></a>5、BeanFactory和FactoryBean的区别？</h2><p>BeanFactory：顶层的容器实现，有一些最基本的方法，如getBean等</p>\n<p>FactoryBean：Bean的工厂，可以根据参数获取不同类型的Bean</p>\n<h2 id=\"6、Bean的生命周期\"><a href=\"#6、Bean的生命周期\" class=\"headerlink\" title=\"6、Bean的生命周期\"></a>6、Bean的生命周期</h2><h2 id=\"7、Spring如何解决循环依赖？\"><a href=\"#7、Spring如何解决循环依赖？\" class=\"headerlink\" title=\"7、Spring如何解决循环依赖？\"></a>7、Spring如何解决循环依赖？</h2><h2 id=\"8、Spring配置中的placeholder占位符是如何替换的？有什么方法可以实现自定义的配置替换？\"><a href=\"#8、Spring配置中的placeholder占位符是如何替换的？有什么方法可以实现自定义的配置替换？\" class=\"headerlink\" title=\"8、Spring配置中的placeholder占位符是如何替换的？有什么方法可以实现自定义的配置替换？\"></a>8、Spring配置中的placeholder占位符是如何替换的？有什么方法可以实现自定义的配置替换？</h2><p>##9、SpringMVC的工作流程</p>\n<h1 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h1><h2 id=\"1、启动流程\"><a href=\"#1、启动流程\" class=\"headerlink\" title=\"1、启动流程\"></a>1、启动流程</h2><h2 id=\"2、bootstrap配置文件和application配置文件的区别\"><a href=\"#2、bootstrap配置文件和application配置文件的区别\" class=\"headerlink\" title=\"2、bootstrap配置文件和application配置文件的区别\"></a>2、bootstrap配置文件和application配置文件的区别</h2><h2 id=\"3、自动配置原理\"><a href=\"#3、自动配置原理\" class=\"headerlink\" title=\"3、自动配置原理\"></a>3、自动配置原理</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Mybatis\"><a href=\"#Mybatis\" class=\"headerlink\" title=\"Mybatis\"></a>Mybatis</h1><h2 id=\"1、Mybatis和Hibernate的区别？\"><a href=\"#1、Mybatis和Hibernate的区别？\" class=\"headerlink\" title=\"1、Mybatis和Hibernate的区别？\"></a>1、Mybatis和Hibernate的区别？</h2><table>\n<thead>\n<tr>\n<th></th>\n<th>Mybatis</th>\n<th>Hibernate</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>ORM</td>\n<td>半自动</td>\n<td>全自动</td>\n</tr>\n<tr>\n<td>SQL</td>\n<td>需要手写sql</td>\n<td>只需要配置表和实体的映射</td>\n</tr>\n<tr>\n<td>优点</td>\n<td>灵活，学习快</td>\n<td>不需要写sql，跨平台</td>\n</tr>\n<tr>\n<td>缺点</td>\n<td>需要写sql，不跨平台</td>\n<td>不够灵活，学习难度高</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<p>##2、#{}和${}的区别</p>\n<h2 id=\"3、\"><a href=\"#3、\" class=\"headerlink\" title=\"3、\"></a>3、</h2><h1 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h1><h2 id=\"1、Spring有哪些模块？\"><a href=\"#1、Spring有哪些模块？\" class=\"headerlink\" title=\"1、Spring有哪些模块？\"></a>1、Spring有哪些模块？</h2><p>##2、动态代理的实现？Cglib和JDK动态代理的区别？</p>\n<p>cglib基于字节码技术，会给被代理类生成子类进行实现，所以不能代理final方法</p>\n<p>JDK动态代理只能代理实现了接口的类</p>\n<h2 id=\"3、事务的传播行为和隔离级别\"><a href=\"#3、事务的传播行为和隔离级别\" class=\"headerlink\" title=\"3、事务的传播行为和隔离级别\"></a>3、事务的传播行为和隔离级别</h2><p>传播行为是指？</p>\n<p>隔离级别与具体的数据库有关，mysql分为RU,RC,RR,Serializable</p>\n<h2 id=\"4、BeanFactory和ApplicationContext的区别\"><a href=\"#4、BeanFactory和ApplicationContext的区别\" class=\"headerlink\" title=\"4、BeanFactory和ApplicationContext的区别?\"></a>4、BeanFactory和ApplicationContext的区别?</h2><h2 id=\"5、BeanFactory和FactoryBean的区别？\"><a href=\"#5、BeanFactory和FactoryBean的区别？\" class=\"headerlink\" title=\"5、BeanFactory和FactoryBean的区别？\"></a>5、BeanFactory和FactoryBean的区别？</h2><p>BeanFactory：顶层的容器实现，有一些最基本的方法，如getBean等</p>\n<p>FactoryBean：Bean的工厂，可以根据参数获取不同类型的Bean</p>\n<h2 id=\"6、Bean的生命周期\"><a href=\"#6、Bean的生命周期\" class=\"headerlink\" title=\"6、Bean的生命周期\"></a>6、Bean的生命周期</h2><h2 id=\"7、Spring如何解决循环依赖？\"><a href=\"#7、Spring如何解决循环依赖？\" class=\"headerlink\" title=\"7、Spring如何解决循环依赖？\"></a>7、Spring如何解决循环依赖？</h2><h2 id=\"8、Spring配置中的placeholder占位符是如何替换的？有什么方法可以实现自定义的配置替换？\"><a href=\"#8、Spring配置中的placeholder占位符是如何替换的？有什么方法可以实现自定义的配置替换？\" class=\"headerlink\" title=\"8、Spring配置中的placeholder占位符是如何替换的？有什么方法可以实现自定义的配置替换？\"></a>8、Spring配置中的placeholder占位符是如何替换的？有什么方法可以实现自定义的配置替换？</h2><p>##9、SpringMVC的工作流程</p>\n<h1 id=\"SpringBoot\"><a href=\"#SpringBoot\" class=\"headerlink\" title=\"SpringBoot\"></a>SpringBoot</h1><h2 id=\"1、启动流程\"><a href=\"#1、启动流程\" class=\"headerlink\" title=\"1、启动流程\"></a>1、启动流程</h2><h2 id=\"2、bootstrap配置文件和application配置文件的区别\"><a href=\"#2、bootstrap配置文件和application配置文件的区别\" class=\"headerlink\" title=\"2、bootstrap配置文件和application配置文件的区别\"></a>2、bootstrap配置文件和application配置文件的区别</h2><h2 id=\"3、自动配置原理\"><a href=\"#3、自动配置原理\" class=\"headerlink\" title=\"3、自动配置原理\"></a>3、自动配置原理</h2>"},{"title":"mybatis设计模式","_content":"\n# 适配器模式\n* 角色：\n\t* Target: 目标角色，期待得到的接口\n\t* Adaptee:适配者角色，被适配的接口\n\t* Adapter:适配器角色，将原接口转换成目标接口\n* 适用场景：当调用双方都不太容易修改的时候，为了服用现有组件可以使用适配器模式；在系统中介入第三方组件的时候经常被用到\n* 代理模式和适配器模式的区别：\n* 代理模式和装饰器模式的区别：\n\n\n# 代理模式\n* 目的：\n1. 通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性\n2.通过代理对象对原有的业务增强","source":"_posts/mybatis/mybatis中的设计模式.md","raw":"---\ntitle: mybatis设计模式\ntags: \n- mybatis\ncategories:\n- mybatis\n---\n\n# 适配器模式\n* 角色：\n\t* Target: 目标角色，期待得到的接口\n\t* Adaptee:适配者角色，被适配的接口\n\t* Adapter:适配器角色，将原接口转换成目标接口\n* 适用场景：当调用双方都不太容易修改的时候，为了服用现有组件可以使用适配器模式；在系统中介入第三方组件的时候经常被用到\n* 代理模式和适配器模式的区别：\n* 代理模式和装饰器模式的区别：\n\n\n# 代理模式\n* 目的：\n1. 通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性\n2.通过代理对象对原有的业务增强","slug":"mybatis/mybatis中的设计模式","published":1,"date":"2019-09-13T02:16:08.435Z","updated":"2019-09-13T02:40:39.588Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5k7001ylcvd7k7qiwm3","content":"<h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><ul>\n<li>角色：<ul>\n<li>Target: 目标角色，期待得到的接口</li>\n<li>Adaptee:适配者角色，被适配的接口</li>\n<li>Adapter:适配器角色，将原接口转换成目标接口</li>\n</ul>\n</li>\n<li>适用场景：当调用双方都不太容易修改的时候，为了服用现有组件可以使用适配器模式；在系统中介入第三方组件的时候经常被用到</li>\n<li>代理模式和适配器模式的区别：</li>\n<li>代理模式和装饰器模式的区别：</li>\n</ul>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><ul>\n<li>目的：</li>\n</ul>\n<ol>\n<li>通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性</li>\n<li>通过代理对象对原有的业务增强</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><ul>\n<li>角色：<ul>\n<li>Target: 目标角色，期待得到的接口</li>\n<li>Adaptee:适配者角色，被适配的接口</li>\n<li>Adapter:适配器角色，将原接口转换成目标接口</li>\n</ul>\n</li>\n<li>适用场景：当调用双方都不太容易修改的时候，为了服用现有组件可以使用适配器模式；在系统中介入第三方组件的时候经常被用到</li>\n<li>代理模式和适配器模式的区别：</li>\n<li>代理模式和装饰器模式的区别：</li>\n</ul>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><ul>\n<li>目的：</li>\n</ul>\n<ol>\n<li>通过引入代理对象的方式来间接访问目标对象，防止直接访问目标对象给系统带来的不必要复杂性</li>\n<li>通过代理对象对原有的业务增强</li>\n</ol>\n"},{"title":"mybatis使用","_content":"\n","source":"_posts/mybatis/mybatis使用.md","raw":"---\ntitle: mybatis使用\ntags: \n- mybatis\ncategories:\n- mybatis\n---\n\n","slug":"mybatis/mybatis使用","published":1,"date":"2019-09-25T12:43:07.123Z","updated":"2019-09-25T12:43:41.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5ka0021lcvdtruhfsts","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"mybatis核心流程","_content":"\n# mybatis核心流程三大阶段\n* 初始化阶段\n> 读取XML配置文件和注解中的配置信息，创建配置对象，并完成各个模块的初始化工作\n\n* 代理阶段\n> 封装iBatis的编程模型，使用mapper接口开发的初始化工作\n\n* 数据读写阶段\n> 通过SqlSession完成SQL解析，参数的映射，SQL的执行，结果的解析过程","source":"_posts/mybatis/mybatis核心流程.md","raw":"---\ntitle: mybatis核心流程\ntags: \n- mybatis\ncategories:\n- mybatis\n---\n\n# mybatis核心流程三大阶段\n* 初始化阶段\n> 读取XML配置文件和注解中的配置信息，创建配置对象，并完成各个模块的初始化工作\n\n* 代理阶段\n> 封装iBatis的编程模型，使用mapper接口开发的初始化工作\n\n* 数据读写阶段\n> 通过SqlSession完成SQL解析，参数的映射，SQL的执行，结果的解析过程","slug":"mybatis/mybatis核心流程","published":1,"date":"2019-09-16T11:43:49.205Z","updated":"2019-09-16T11:47:32.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5kc0025lcvdfpweu2iv","content":"<h1 id=\"mybatis核心流程三大阶段\"><a href=\"#mybatis核心流程三大阶段\" class=\"headerlink\" title=\"mybatis核心流程三大阶段\"></a>mybatis核心流程三大阶段</h1><ul>\n<li><p>初始化阶段</p>\n<blockquote>\n<p>读取XML配置文件和注解中的配置信息，创建配置对象，并完成各个模块的初始化工作</p>\n</blockquote>\n</li>\n<li><p>代理阶段</p>\n<blockquote>\n<p>封装iBatis的编程模型，使用mapper接口开发的初始化工作</p>\n</blockquote>\n</li>\n<li><p>数据读写阶段</p>\n<blockquote>\n<p>通过SqlSession完成SQL解析，参数的映射，SQL的执行，结果的解析过程</p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"mybatis核心流程三大阶段\"><a href=\"#mybatis核心流程三大阶段\" class=\"headerlink\" title=\"mybatis核心流程三大阶段\"></a>mybatis核心流程三大阶段</h1><ul>\n<li><p>初始化阶段</p>\n<blockquote>\n<p>读取XML配置文件和注解中的配置信息，创建配置对象，并完成各个模块的初始化工作</p>\n</blockquote>\n</li>\n<li><p>代理阶段</p>\n<blockquote>\n<p>封装iBatis的编程模型，使用mapper接口开发的初始化工作</p>\n</blockquote>\n</li>\n<li><p>数据读写阶段</p>\n<blockquote>\n<p>通过SqlSession完成SQL解析，参数的映射，SQL的执行，结果的解析过程</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"代理模式","_content":"\n# 定义： 为其他对象提供一种代理，以控制这个对象的访问\n> 代理对象在客户端和目标对象之间起到中介的作用\n# 类型：结构型\n\n# 适用场景：\n* 保护目标对象\n* 增强目标对象\n\t\n# 优点：\n* 代理模式能将代理对象与真实被调用的目标对象分离\n* 一定程度上降低了系统的耦合度，扩展性好\n* 保护目标对象\n* 增强目标对象\n\n# 缺点：\n* 代理模式会造成系统设计中类的数目增加\n* 在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢\n* 增加系统的复杂度\n\n# 扩展：\n* 静态代理\n* 动态对象\n* CGLib代理： \n\n# 相关设计模式比较\n* 代理模式和装饰者模式\n>  代理模式和装饰者模式实现上比较相似,目的不同，**装饰者模式是为对象加上行为，代理模式是控制访问，代理模式更加注重通过设置代理人的方式增强目标对象，一般是通过增加目标对象的某些行为** \n* 代理模式和适配器模式\n> **适配器模式主要考虑改变对象的接口，代理模式是不能改变被代理对象的接口**","source":"_posts/设计模式/代理模式.md","raw":"---\ntitle: 代理模式\ntags: \n- 设计模式\ncategories:\n- 设计模式\n---\n\n# 定义： 为其他对象提供一种代理，以控制这个对象的访问\n> 代理对象在客户端和目标对象之间起到中介的作用\n# 类型：结构型\n\n# 适用场景：\n* 保护目标对象\n* 增强目标对象\n\t\n# 优点：\n* 代理模式能将代理对象与真实被调用的目标对象分离\n* 一定程度上降低了系统的耦合度，扩展性好\n* 保护目标对象\n* 增强目标对象\n\n# 缺点：\n* 代理模式会造成系统设计中类的数目增加\n* 在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢\n* 增加系统的复杂度\n\n# 扩展：\n* 静态代理\n* 动态对象\n* CGLib代理： \n\n# 相关设计模式比较\n* 代理模式和装饰者模式\n>  代理模式和装饰者模式实现上比较相似,目的不同，**装饰者模式是为对象加上行为，代理模式是控制访问，代理模式更加注重通过设置代理人的方式增强目标对象，一般是通过增加目标对象的某些行为** \n* 代理模式和适配器模式\n> **适配器模式主要考虑改变对象的接口，代理模式是不能改变被代理对象的接口**","slug":"设计模式/代理模式","published":1,"date":"2019-09-14T11:56:37.038Z","updated":"2019-09-14T12:36:49.272Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5kf0029lcvdd49rirqi","content":"<h1 id=\"定义：-为其他对象提供一种代理，以控制这个对象的访问\"><a href=\"#定义：-为其他对象提供一种代理，以控制这个对象的访问\" class=\"headerlink\" title=\"定义： 为其他对象提供一种代理，以控制这个对象的访问\"></a>定义： 为其他对象提供一种代理，以控制这个对象的访问</h1><blockquote>\n<p>代理对象在客户端和目标对象之间起到中介的作用</p>\n</blockquote>\n<h1 id=\"类型：结构型\"><a href=\"#类型：结构型\" class=\"headerlink\" title=\"类型：结构型\"></a>类型：结构型</h1><h1 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h1><ul>\n<li>保护目标对象</li>\n<li>增强目标对象</li>\n</ul>\n<h1 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h1><ul>\n<li>代理模式能将代理对象与真实被调用的目标对象分离</li>\n<li>一定程度上降低了系统的耦合度，扩展性好</li>\n<li>保护目标对象</li>\n<li>增强目标对象</li>\n</ul>\n<h1 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h1><ul>\n<li>代理模式会造成系统设计中类的数目增加</li>\n<li>在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢</li>\n<li>增加系统的复杂度</li>\n</ul>\n<h1 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h1><ul>\n<li>静态代理</li>\n<li>动态对象</li>\n<li>CGLib代理： </li>\n</ul>\n<h1 id=\"相关设计模式比较\"><a href=\"#相关设计模式比较\" class=\"headerlink\" title=\"相关设计模式比较\"></a>相关设计模式比较</h1><ul>\n<li>代理模式和装饰者模式<blockquote>\n<p> 代理模式和装饰者模式实现上比较相似,目的不同，<strong>装饰者模式是为对象加上行为，代理模式是控制访问，代理模式更加注重通过设置代理人的方式增强目标对象，一般是通过增加目标对象的某些行为</strong> </p>\n</blockquote>\n</li>\n<li>代理模式和适配器模式<blockquote>\n<p><strong>适配器模式主要考虑改变对象的接口，代理模式是不能改变被代理对象的接口</strong></p>\n</blockquote>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"定义：-为其他对象提供一种代理，以控制这个对象的访问\"><a href=\"#定义：-为其他对象提供一种代理，以控制这个对象的访问\" class=\"headerlink\" title=\"定义： 为其他对象提供一种代理，以控制这个对象的访问\"></a>定义： 为其他对象提供一种代理，以控制这个对象的访问</h1><blockquote>\n<p>代理对象在客户端和目标对象之间起到中介的作用</p>\n</blockquote>\n<h1 id=\"类型：结构型\"><a href=\"#类型：结构型\" class=\"headerlink\" title=\"类型：结构型\"></a>类型：结构型</h1><h1 id=\"适用场景：\"><a href=\"#适用场景：\" class=\"headerlink\" title=\"适用场景：\"></a>适用场景：</h1><ul>\n<li>保护目标对象</li>\n<li>增强目标对象</li>\n</ul>\n<h1 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h1><ul>\n<li>代理模式能将代理对象与真实被调用的目标对象分离</li>\n<li>一定程度上降低了系统的耦合度，扩展性好</li>\n<li>保护目标对象</li>\n<li>增强目标对象</li>\n</ul>\n<h1 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h1><ul>\n<li>代理模式会造成系统设计中类的数目增加</li>\n<li>在客户端和目标对象增加一个代理对象，会造成请求处理速度变慢</li>\n<li>增加系统的复杂度</li>\n</ul>\n<h1 id=\"扩展：\"><a href=\"#扩展：\" class=\"headerlink\" title=\"扩展：\"></a>扩展：</h1><ul>\n<li>静态代理</li>\n<li>动态对象</li>\n<li>CGLib代理： </li>\n</ul>\n<h1 id=\"相关设计模式比较\"><a href=\"#相关设计模式比较\" class=\"headerlink\" title=\"相关设计模式比较\"></a>相关设计模式比较</h1><ul>\n<li>代理模式和装饰者模式<blockquote>\n<p> 代理模式和装饰者模式实现上比较相似,目的不同，<strong>装饰者模式是为对象加上行为，代理模式是控制访问，代理模式更加注重通过设置代理人的方式增强目标对象，一般是通过增加目标对象的某些行为</strong> </p>\n</blockquote>\n</li>\n<li>代理模式和适配器模式<blockquote>\n<p><strong>适配器模式主要考虑改变对象的接口，代理模式是不能改变被代理对象的接口</strong></p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"建造者模式","_content":"\n# 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n> 用户只需指定需要建造的类型就可以得到它们，建造过程及细节不需要知道\n\n# 类型：创建型\n\n# 适用场景\n* 如果一个对象有非常复杂的内部结构(很多属性)\n* 想把复杂对象的创建和适用分离\n\n# 优点\n* 封装性好，创建和使用分离\n* 扩展性好，建造类之间独立，一定程度上解耦\n\n# 缺点：\n* 产生多余的Builder对象\n* 产品内部发生变化，建造者都要修改，成本较大\n\n# 相关设计模式\n* 建造者模式和工厂模式\n\t* 建造者模式更注重方法的调用顺序，而工厂模式注重于创建产品\n\t* 创建对象的粒度：建造者模式可以创建一些复杂的产品，由各种复杂的部件组成；工厂模式创建出来都是一个样子\n\t* 关注点：工厂模式只要把对象创建出来就可以，建造者模式还关心创建出来的由哪些部件组成","source":"_posts/设计模式/建造者模式.md","raw":"---\ntitle: 建造者模式\ntags: \n- 设计模式\ncategories:\n- 设计模式\n---\n\n# 定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\n> 用户只需指定需要建造的类型就可以得到它们，建造过程及细节不需要知道\n\n# 类型：创建型\n\n# 适用场景\n* 如果一个对象有非常复杂的内部结构(很多属性)\n* 想把复杂对象的创建和适用分离\n\n# 优点\n* 封装性好，创建和使用分离\n* 扩展性好，建造类之间独立，一定程度上解耦\n\n# 缺点：\n* 产生多余的Builder对象\n* 产品内部发生变化，建造者都要修改，成本较大\n\n# 相关设计模式\n* 建造者模式和工厂模式\n\t* 建造者模式更注重方法的调用顺序，而工厂模式注重于创建产品\n\t* 创建对象的粒度：建造者模式可以创建一些复杂的产品，由各种复杂的部件组成；工厂模式创建出来都是一个样子\n\t* 关注点：工厂模式只要把对象创建出来就可以，建造者模式还关心创建出来的由哪些部件组成","slug":"设计模式/建造者模式","published":1,"date":"2019-09-15T13:05:07.433Z","updated":"2019-09-15T14:08:15.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5kh002dlcvdk1l1mzca","content":"<h1 id=\"定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\"><a href=\"#定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\" class=\"headerlink\" title=\"定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\"></a>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</h1><blockquote>\n<p>用户只需指定需要建造的类型就可以得到它们，建造过程及细节不需要知道</p>\n</blockquote>\n<h1 id=\"类型：创建型\"><a href=\"#类型：创建型\" class=\"headerlink\" title=\"类型：创建型\"></a>类型：创建型</h1><h1 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h1><ul>\n<li>如果一个对象有非常复杂的内部结构(很多属性)</li>\n<li>想把复杂对象的创建和适用分离</li>\n</ul>\n<h1 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h1><ul>\n<li>封装性好，创建和使用分离</li>\n<li>扩展性好，建造类之间独立，一定程度上解耦</li>\n</ul>\n<h1 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h1><ul>\n<li>产生多余的Builder对象</li>\n<li>产品内部发生变化，建造者都要修改，成本较大</li>\n</ul>\n<h1 id=\"相关设计模式\"><a href=\"#相关设计模式\" class=\"headerlink\" title=\"相关设计模式\"></a>相关设计模式</h1><ul>\n<li>建造者模式和工厂模式<ul>\n<li>建造者模式更注重方法的调用顺序，而工厂模式注重于创建产品</li>\n<li>创建对象的粒度：建造者模式可以创建一些复杂的产品，由各种复杂的部件组成；工厂模式创建出来都是一个样子</li>\n<li>关注点：工厂模式只要把对象创建出来就可以，建造者模式还关心创建出来的由哪些部件组成</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\"><a href=\"#定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\" class=\"headerlink\" title=\"定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示\"></a>定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</h1><blockquote>\n<p>用户只需指定需要建造的类型就可以得到它们，建造过程及细节不需要知道</p>\n</blockquote>\n<h1 id=\"类型：创建型\"><a href=\"#类型：创建型\" class=\"headerlink\" title=\"类型：创建型\"></a>类型：创建型</h1><h1 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a>适用场景</h1><ul>\n<li>如果一个对象有非常复杂的内部结构(很多属性)</li>\n<li>想把复杂对象的创建和适用分离</li>\n</ul>\n<h1 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h1><ul>\n<li>封装性好，创建和使用分离</li>\n<li>扩展性好，建造类之间独立，一定程度上解耦</li>\n</ul>\n<h1 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h1><ul>\n<li>产生多余的Builder对象</li>\n<li>产品内部发生变化，建造者都要修改，成本较大</li>\n</ul>\n<h1 id=\"相关设计模式\"><a href=\"#相关设计模式\" class=\"headerlink\" title=\"相关设计模式\"></a>相关设计模式</h1><ul>\n<li>建造者模式和工厂模式<ul>\n<li>建造者模式更注重方法的调用顺序，而工厂模式注重于创建产品</li>\n<li>创建对象的粒度：建造者模式可以创建一些复杂的产品，由各种复杂的部件组成；工厂模式创建出来都是一个样子</li>\n<li>关注点：工厂模式只要把对象创建出来就可以，建造者模式还关心创建出来的由哪些部件组成</li>\n</ul>\n</li>\n</ul>\n"},{"title":"模板模式","_content":"\n# 定义\n> 一个抽象类公开定义了执行它的方法/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式执行。定义一个操作的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定实现。\n\n\n# 源码\n* AQS的tryAcquire,tryRelease, tryAcquireShared, tryReleaseShared\n* Spring中对数据存储，HibernateTemplate,JdbcTemplate,RedisTemplate,MongodbTemplate\n* Mybatis中BaseExecutor","source":"_posts/设计模式/模板模式.md","raw":"---\ntitle: 模板模式\ntags: \n- 设计模式\ncategories:\n- 设计模式\n---\n\n# 定义\n> 一个抽象类公开定义了执行它的方法/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式执行。定义一个操作的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定实现。\n\n\n# 源码\n* AQS的tryAcquire,tryRelease, tryAcquireShared, tryReleaseShared\n* Spring中对数据存储，HibernateTemplate,JdbcTemplate,RedisTemplate,MongodbTemplate\n* Mybatis中BaseExecutor","slug":"设计模式/模板模式","published":1,"date":"2019-09-19T12:57:20.752Z","updated":"2019-09-19T13:03:56.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5kk002hlcvdeaq5wtkv","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><blockquote>\n<p>一个抽象类公开定义了执行它的方法/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式执行。定义一个操作的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定实现。</p>\n</blockquote>\n<h1 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1><ul>\n<li>AQS的tryAcquire,tryRelease, tryAcquireShared, tryReleaseShared</li>\n<li>Spring中对数据存储，HibernateTemplate,JdbcTemplate,RedisTemplate,MongodbTemplate</li>\n<li>Mybatis中BaseExecutor</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><blockquote>\n<p>一个抽象类公开定义了执行它的方法/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式执行。定义一个操作的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定实现。</p>\n</blockquote>\n<h1 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1><ul>\n<li>AQS的tryAcquire,tryRelease, tryAcquireShared, tryReleaseShared</li>\n<li>Spring中对数据存储，HibernateTemplate,JdbcTemplate,RedisTemplate,MongodbTemplate</li>\n<li>Mybatis中BaseExecutor</li>\n</ul>\n"},{"title":"策略模式","_content":"\n# 策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化\n\n# 使用场景\n* 针对同一类型的多种处理方式，仅仅是具体行为有差别时；\n* 出现同一抽象有多个子类，而又需要使用if-else或者switch-case来选择具体子类时\n\n# 组件\n* Context：算法调用者，使用setCategory方法灵活的选择策略\n* Strategy：算法的同一接口\n* ConcreteStrategy:算法的具体实现\n\n# 源码\n* Spring中","source":"_posts/设计模式/策略模式.md","raw":"---\ntitle: 策略模式\ntags: \n- 设计模式\ncategories:\n- 设计模式\n---\n\n# 策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化\n\n# 使用场景\n* 针对同一类型的多种处理方式，仅仅是具体行为有差别时；\n* 出现同一抽象有多个子类，而又需要使用if-else或者switch-case来选择具体子类时\n\n# 组件\n* Context：算法调用者，使用setCategory方法灵活的选择策略\n* Strategy：算法的同一接口\n* ConcreteStrategy:算法的具体实现\n\n# 源码\n* Spring中","slug":"设计模式/策略模式","published":1,"date":"2019-09-18T14:07:20.352Z","updated":"2019-09-18T14:34:31.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5kn002llcvdfb9vi2fy","content":"<h1 id=\"策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化\"><a href=\"#策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化\" class=\"headerlink\" title=\"策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化\"></a>策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化</h1><h1 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h1><ul>\n<li>针对同一类型的多种处理方式，仅仅是具体行为有差别时；</li>\n<li>出现同一抽象有多个子类，而又需要使用if-else或者switch-case来选择具体子类时</li>\n</ul>\n<h1 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h1><ul>\n<li>Context：算法调用者，使用setCategory方法灵活的选择策略</li>\n<li>Strategy：算法的同一接口</li>\n<li>ConcreteStrategy:算法的具体实现</li>\n</ul>\n<h1 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1><ul>\n<li>Spring中</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化\"><a href=\"#策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化\" class=\"headerlink\" title=\"策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化\"></a>策略模式：定义了一系列的算法，并将每一个算法封装起来，而且使他们可以相互替换，让算法独立于使用它的客户而独立变化</h1><h1 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h1><ul>\n<li>针对同一类型的多种处理方式，仅仅是具体行为有差别时；</li>\n<li>出现同一抽象有多个子类，而又需要使用if-else或者switch-case来选择具体子类时</li>\n</ul>\n<h1 id=\"组件\"><a href=\"#组件\" class=\"headerlink\" title=\"组件\"></a>组件</h1><ul>\n<li>Context：算法调用者，使用setCategory方法灵活的选择策略</li>\n<li>Strategy：算法的同一接口</li>\n<li>ConcreteStrategy:算法的具体实现</li>\n</ul>\n<h1 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1><ul>\n<li>Spring中</li>\n</ul>\n"},{"title":"装饰器模式","_content":"\n# 定义\n>装饰器模式允许向一个现有的对象添加新的功能，是一种用于替代继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀\n\n# 优点：\n* 相对于继承，装饰器模式灵活性更强，扩展性更强\n\n# 使用举例\n* IO输入流和输出流:\n```\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(\"c://a.txt\")));\n```\n* Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper,HttpServletRequestWrapper类增强了request对象的功能\n* MyBatis的缓存组件","source":"_posts/设计模式/装饰器模式.md","raw":"---\ntitle: 装饰器模式\ntags: \n- 设计模式\ncategories:\n- 设计模式\n---\n\n# 定义\n>装饰器模式允许向一个现有的对象添加新的功能，是一种用于替代继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀\n\n# 优点：\n* 相对于继承，装饰器模式灵活性更强，扩展性更强\n\n# 使用举例\n* IO输入流和输出流:\n```\nBufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(\"c://a.txt\")));\n```\n* Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper,HttpServletRequestWrapper类增强了request对象的功能\n* MyBatis的缓存组件","slug":"设计模式/装饰器模式","published":1,"date":"2019-09-14T23:38:10.199Z","updated":"2019-09-14T23:50:43.990Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5kq002plcvdhq6e7s9n","content":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><blockquote>\n<p>装饰器模式允许向一个现有的对象添加新的功能，是一种用于替代继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀</p>\n</blockquote>\n<h1 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h1><ul>\n<li>相对于继承，装饰器模式灵活性更强，扩展性更强</li>\n</ul>\n<h1 id=\"使用举例\"><a href=\"#使用举例\" class=\"headerlink\" title=\"使用举例\"></a>使用举例</h1><ul>\n<li><p>IO输入流和输出流:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;c://a.txt&quot;)));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper,HttpServletRequestWrapper类增强了request对象的功能</p>\n</li>\n<li><p>MyBatis的缓存组件</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h1><blockquote>\n<p>装饰器模式允许向一个现有的对象添加新的功能，是一种用于替代继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀</p>\n</blockquote>\n<h1 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h1><ul>\n<li>相对于继承，装饰器模式灵活性更强，扩展性更强</li>\n</ul>\n<h1 id=\"使用举例\"><a href=\"#使用举例\" class=\"headerlink\" title=\"使用举例\"></a>使用举例</h1><ul>\n<li><p>IO输入流和输出流:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(new FileInputStream(&quot;c://a.txt&quot;)));</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Servlet API中提供了一个request对象的Decorator设计模式的默认实现类HttpServletRequestWrapper,HttpServletRequestWrapper类增强了request对象的功能</p>\n</li>\n<li><p>MyBatis的缓存组件</p>\n</li>\n</ul>\n"},{"title":"spring声明式事务底层源码","_content":"\n# 注解\n* 开启事务管理功能，对@Transactional起作用：EnableTransactionManagement\n\n源码和AOP相似\n\n* @EnableTransactionManagement\n\t* @Import(TransactionManagementConfigurationSelector.class)\n\t\t\t* AutoProxyRegistrar.registerBeanDefinitions()\n\t\t\t\t* 注册InfrastructureAdvisorAutoProxyCreator\n\t\t\t* ProxyTransactionManagementConfiguration\n\t\t\t\t* transactionAttributeSource()\n\t\t\t\t\t* AnnotationTransactionAttributeSource()\n\t\t\t\t\t\t* SpringTransactionAnnotationParser() ：解析@Transactional的属性\n\t\t\t\t* TransactionInterceptor() : 实现了MethodInterceptor，被AOP拦截\n\t\t\t\t\t* completeTransactionAfterThrowing(txInfo, ex);","source":"_posts/spring/声明式事务底层源码.md","raw":"---\ntitle: spring声明式事务底层源码\ntags: \n- spring\ncategories:\n- spring\n---\n\n# 注解\n* 开启事务管理功能，对@Transactional起作用：EnableTransactionManagement\n\n源码和AOP相似\n\n* @EnableTransactionManagement\n\t* @Import(TransactionManagementConfigurationSelector.class)\n\t\t\t* AutoProxyRegistrar.registerBeanDefinitions()\n\t\t\t\t* 注册InfrastructureAdvisorAutoProxyCreator\n\t\t\t* ProxyTransactionManagementConfiguration\n\t\t\t\t* transactionAttributeSource()\n\t\t\t\t\t* AnnotationTransactionAttributeSource()\n\t\t\t\t\t\t* SpringTransactionAnnotationParser() ：解析@Transactional的属性\n\t\t\t\t* TransactionInterceptor() : 实现了MethodInterceptor，被AOP拦截\n\t\t\t\t\t* completeTransactionAfterThrowing(txInfo, ex);","slug":"spring/声明式事务底层源码","published":1,"date":"2019-09-12T13:26:46.306Z","updated":"2019-09-13T01:38:40.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5kt002slcvd3ep0fqze","content":"<h1 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h1><ul>\n<li>开启事务管理功能，对@Transactional起作用：EnableTransactionManagement</li>\n</ul>\n<p>源码和AOP相似</p>\n<ul>\n<li>@EnableTransactionManagement<ul>\n<li>@Import(TransactionManagementConfigurationSelector.class)<pre><code>* AutoProxyRegistrar.registerBeanDefinitions()\n    * 注册InfrastructureAdvisorAutoProxyCreator\n* ProxyTransactionManagementConfiguration\n    * transactionAttributeSource()\n        * AnnotationTransactionAttributeSource()\n            * SpringTransactionAnnotationParser() ：解析@Transactional的属性\n    * TransactionInterceptor() : 实现了MethodInterceptor，被AOP拦截\n        * completeTransactionAfterThrowing(txInfo, ex);</code></pre></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"注解\"><a href=\"#注解\" class=\"headerlink\" title=\"注解\"></a>注解</h1><ul>\n<li>开启事务管理功能，对@Transactional起作用：EnableTransactionManagement</li>\n</ul>\n<p>源码和AOP相似</p>\n<ul>\n<li>@EnableTransactionManagement<ul>\n<li>@Import(TransactionManagementConfigurationSelector.class)<pre><code>* AutoProxyRegistrar.registerBeanDefinitions()\n    * 注册InfrastructureAdvisorAutoProxyCreator\n* ProxyTransactionManagementConfiguration\n    * transactionAttributeSource()\n        * AnnotationTransactionAttributeSource()\n            * SpringTransactionAnnotationParser() ：解析@Transactional的属性\n    * TransactionInterceptor() : 实现了MethodInterceptor，被AOP拦截\n        * completeTransactionAfterThrowing(txInfo, ex);</code></pre></li>\n</ul>\n</li>\n</ul>\n"},{"title":"阻塞队列","_content":"\n# 特点\n* 当阻塞队列是空时，从队列中获取元素的操作将会被阻塞；\n* 当阻塞队列是满时，往队列里添加元素的操作将会被阻塞；\n\n# 为什么需要阻塞队列？\n> 好处是我不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了\n\n# 架构介绍\n* BlockingQueue\n\t* LinkedTransferQueue：由链表结构组成的无界阻塞队列\n\t* LinkedBlockingDeque:由链表结构组成的有界阻塞队列（默认大小是Integer.MAX_VALUE）\n\t* PriorityBlockingQueue:支持优先级排序的无界阻塞队列\n\t* SynchronousQueue：不存储元素的阻塞队列，即单个元素的队列\n\t* DelayQueue：使用优先级队列实现的延迟无界阻塞队列\n\t* ArrayBlockingQueue:由数组结构组成的有界阻塞队列\n\t* LinkedBlockingQueue：由链表结构组成的双向阻塞队列\n\t\n\t\n# 核心方法\n","source":"_posts/multiThread/阻塞队列.md","raw":"---\ntitle: 阻塞队列\ntags: \n- 阻塞队列\ncategories:\n- 并发编程\n---\n\n# 特点\n* 当阻塞队列是空时，从队列中获取元素的操作将会被阻塞；\n* 当阻塞队列是满时，往队列里添加元素的操作将会被阻塞；\n\n# 为什么需要阻塞队列？\n> 好处是我不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了\n\n# 架构介绍\n* BlockingQueue\n\t* LinkedTransferQueue：由链表结构组成的无界阻塞队列\n\t* LinkedBlockingDeque:由链表结构组成的有界阻塞队列（默认大小是Integer.MAX_VALUE）\n\t* PriorityBlockingQueue:支持优先级排序的无界阻塞队列\n\t* SynchronousQueue：不存储元素的阻塞队列，即单个元素的队列\n\t* DelayQueue：使用优先级队列实现的延迟无界阻塞队列\n\t* ArrayBlockingQueue:由数组结构组成的有界阻塞队列\n\t* LinkedBlockingQueue：由链表结构组成的双向阻塞队列\n\t\n\t\n# 核心方法\n","slug":"multiThread/阻塞队列","published":1,"date":"2019-09-17T13:16:44.268Z","updated":"2019-09-18T13:35:25.121Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck3ioq5kx002wlcvd4avr5q35","content":"<h1 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h1><ul>\n<li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞；</li>\n<li>当阻塞队列是满时，往队列里添加元素的操作将会被阻塞；</li>\n</ul>\n<h1 id=\"为什么需要阻塞队列？\"><a href=\"#为什么需要阻塞队列？\" class=\"headerlink\" title=\"为什么需要阻塞队列？\"></a>为什么需要阻塞队列？</h1><blockquote>\n<p>好处是我不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p>\n</blockquote>\n<h1 id=\"架构介绍\"><a href=\"#架构介绍\" class=\"headerlink\" title=\"架构介绍\"></a>架构介绍</h1><ul>\n<li>BlockingQueue<ul>\n<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li>\n<li>LinkedBlockingDeque:由链表结构组成的有界阻塞队列（默认大小是Integer.MAX_VALUE）</li>\n<li>PriorityBlockingQueue:支持优先级排序的无界阻塞队列</li>\n<li>SynchronousQueue：不存储元素的阻塞队列，即单个元素的队列</li>\n<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li>\n<li>ArrayBlockingQueue:由数组结构组成的有界阻塞队列</li>\n<li>LinkedBlockingQueue：由链表结构组成的双向阻塞队列</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"特点\"><a href=\"#特点\" class=\"headerlink\" title=\"特点\"></a>特点</h1><ul>\n<li>当阻塞队列是空时，从队列中获取元素的操作将会被阻塞；</li>\n<li>当阻塞队列是满时，往队列里添加元素的操作将会被阻塞；</li>\n</ul>\n<h1 id=\"为什么需要阻塞队列？\"><a href=\"#为什么需要阻塞队列？\" class=\"headerlink\" title=\"为什么需要阻塞队列？\"></a>为什么需要阻塞队列？</h1><blockquote>\n<p>好处是我不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了</p>\n</blockquote>\n<h1 id=\"架构介绍\"><a href=\"#架构介绍\" class=\"headerlink\" title=\"架构介绍\"></a>架构介绍</h1><ul>\n<li>BlockingQueue<ul>\n<li>LinkedTransferQueue：由链表结构组成的无界阻塞队列</li>\n<li>LinkedBlockingDeque:由链表结构组成的有界阻塞队列（默认大小是Integer.MAX_VALUE）</li>\n<li>PriorityBlockingQueue:支持优先级排序的无界阻塞队列</li>\n<li>SynchronousQueue：不存储元素的阻塞队列，即单个元素的队列</li>\n<li>DelayQueue：使用优先级队列实现的延迟无界阻塞队列</li>\n<li>ArrayBlockingQueue:由数组结构组成的有界阻塞队列</li>\n<li>LinkedBlockingQueue：由链表结构组成的双向阻塞队列</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h1>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck3ioq5id0005lcvdpg30kkrs","category_id":"ck3ioq5i80002lcvdbbmsr2z7","_id":"ck3ioq5io000clcvdd59u7buf"},{"post_id":"ck3ioq5hy0000lcvdkie6j2ir","category_id":"ck3ioq5i80002lcvdbbmsr2z7","_id":"ck3ioq5ir000glcvd4g6mhfpn"},{"post_id":"ck3ioq5i50001lcvdxwkr71gr","category_id":"ck3ioq5i80002lcvdbbmsr2z7","_id":"ck3ioq5iv000klcvd5j8kv6yy"},{"post_id":"ck3ioq5ib0004lcvdown5xuvy","category_id":"ck3ioq5i80002lcvdbbmsr2z7","_id":"ck3ioq5j6000plcvd3z9vmibb"},{"post_id":"ck3ioq5ij000alcvdaw0jlxhz","category_id":"ck3ioq5iv000jlcvdwxuan41u","_id":"ck3ioq5jd000vlcvdf8sc3whv"},{"post_id":"ck3ioq5in000blcvdvsny1zhs","category_id":"ck3ioq5j7000qlcvdrmrwcopz","_id":"ck3ioq5jh0011lcvdck7ht1om"},{"post_id":"ck3ioq5iq000flcvdd2fx4k8g","category_id":"ck3ioq5jd000wlcvdprka6rk4","_id":"ck3ioq5jn0018lcvdjfkpnxhv"},{"post_id":"ck3ioq5is000ilcvdbm05o8hz","category_id":"ck3ioq5iv000jlcvdwxuan41u","_id":"ck3ioq5jr001dlcvdfsfyt09r"},{"post_id":"ck3ioq5j3000olcvdzpuox7jf","category_id":"ck3ioq5jn0017lcvd0mzujz6i","_id":"ck3ioq5jw001klcvdtce3cfuc"},{"post_id":"ck3ioq5jb000ulcvdbgb0uoei","category_id":"ck3ioq5js001flcvdqabmdhjp","_id":"ck3ioq5k2001rlcvdvxoh7ugi"},{"post_id":"ck3ioq5je000xlcvd2alan9i1","category_id":"ck3ioq5js001flcvdqabmdhjp","_id":"ck3ioq5k7001xlcvdlk0iz8w6"},{"post_id":"ck3ioq5k3001slcvd93f7ruua","category_id":"ck3ioq5js001flcvdqabmdhjp","_id":"ck3ioq5kb0022lcvd75zq2yyo"},{"post_id":"ck3ioq5jg0010lcvd5z0e62uz","category_id":"ck3ioq5js001flcvdqabmdhjp","_id":"ck3ioq5kd0026lcvd8v373u3j"},{"post_id":"ck3ioq5k7001ylcvd7k7qiwm3","category_id":"ck3ioq5jd000wlcvdprka6rk4","_id":"ck3ioq5kg002alcvd9gpsl0hh"},{"post_id":"ck3ioq5ji0013lcvd7h1c2b5q","category_id":"ck3ioq5js001flcvdqabmdhjp","_id":"ck3ioq5kj002elcvd9sl9b2qf"},{"post_id":"ck3ioq5ka0021lcvdtruhfsts","category_id":"ck3ioq5jd000wlcvdprka6rk4","_id":"ck3ioq5kl002ilcvd3le71hco"},{"post_id":"ck3ioq5kc0025lcvdfpweu2iv","category_id":"ck3ioq5jd000wlcvdprka6rk4","_id":"ck3ioq5ko002mlcvdov16fjgy"},{"post_id":"ck3ioq5jn0019lcvdc3vwz816","category_id":"ck3ioq5kb0023lcvd9xjjru4d","_id":"ck3ioq5ks002qlcvd3pusqdsm"},{"post_id":"ck3ioq5jp001blcvd0vh1x0ud","category_id":"ck3ioq5kg002blcvdqfh8itni","_id":"ck3ioq5kv002tlcvd13yv7s9r"},{"post_id":"ck3ioq5jt001hlcvd29noji9u","category_id":"ck3ioq5kn002klcvdrlghjhaz","_id":"ck3ioq5l1002zlcvdrml3pxun"},{"post_id":"ck3ioq5kt002slcvd3ep0fqze","category_id":"ck3ioq5js001flcvdqabmdhjp","_id":"ck3ioq5l40032lcvdc1nfzu0x"},{"post_id":"ck3ioq5kx002wlcvd4avr5q35","category_id":"ck3ioq5j7000qlcvdrmrwcopz","_id":"ck3ioq5l60035lcvdslzdbqr1"},{"post_id":"ck3ioq5jv001jlcvdld8bdgng","category_id":"ck3ioq5kw002ulcvd3mnop2ly","_id":"ck3ioq5l70038lcvdntg3ph0z"},{"post_id":"ck3ioq5k0001plcvda7ubdj7w","category_id":"ck3ioq5kn002klcvdrlghjhaz","_id":"ck3ioq5l9003blcvdsldhpueh"},{"post_id":"ck3ioq5k5001ulcvd8r6otijb","category_id":"ck3ioq5l60036lcvd804jirxx","_id":"ck3ioq5lb003glcvdryj69neu"},{"post_id":"ck3ioq5kf0029lcvdd49rirqi","category_id":"ck3ioq5l9003clcvdhoocfjzm","_id":"ck3ioq5le003nlcvdffapgje5"},{"post_id":"ck3ioq5kh002dlcvdk1l1mzca","category_id":"ck3ioq5l9003clcvdhoocfjzm","_id":"ck3ioq5lg003qlcvdx3th2ad9"},{"post_id":"ck3ioq5kk002hlcvdeaq5wtkv","category_id":"ck3ioq5l9003clcvdhoocfjzm","_id":"ck3ioq5lj003tlcvdzg5nmwzz"},{"post_id":"ck3ioq5kn002llcvdfb9vi2fy","category_id":"ck3ioq5l9003clcvdhoocfjzm","_id":"ck3ioq5lk003vlcvdmqo8gjhs"},{"post_id":"ck3ioq5kq002plcvdhq6e7s9n","category_id":"ck3ioq5l9003clcvdhoocfjzm","_id":"ck3ioq5lk003wlcvdek1w4gm9"}],"PostTag":[{"post_id":"ck3ioq5hy0000lcvdkie6j2ir","tag_id":"ck3ioq5ia0003lcvd833c3qwx","_id":"ck3ioq5ij0009lcvdnoetyyjv"},{"post_id":"ck3ioq5i50001lcvdxwkr71gr","tag_id":"ck3ioq5ig0008lcvdoxyoyrrl","_id":"ck3ioq5is000hlcvdy40jaohh"},{"post_id":"ck3ioq5ib0004lcvdown5xuvy","tag_id":"ck3ioq5ip000elcvdacr0bdq8","_id":"ck3ioq5j2000nlcvdcd907dyj"},{"post_id":"ck3ioq5id0005lcvdpg30kkrs","tag_id":"ck3ioq5ix000llcvdjfa08khd","_id":"ck3ioq5jb000tlcvd52v1t7bb"},{"post_id":"ck3ioq5ij000alcvdaw0jlxhz","tag_id":"ck3ioq5j8000rlcvdu1u3e0b2","_id":"ck3ioq5jf000zlcvdzok30mmf"},{"post_id":"ck3ioq5in000blcvdvsny1zhs","tag_id":"ck3ioq5jf000ylcvdp11dtxt3","_id":"ck3ioq5jm0016lcvd0rh6num9"},{"post_id":"ck3ioq5iq000flcvdd2fx4k8g","tag_id":"ck3ioq5jk0014lcvdd6m3g4kp","_id":"ck3ioq5jq001clcvd8sgts5sb"},{"post_id":"ck3ioq5is000ilcvdbm05o8hz","tag_id":"ck3ioq5jp001alcvdswhrxv5t","_id":"ck3ioq5jv001ilcvdg2dhgq2s"},{"post_id":"ck3ioq5j3000olcvdzpuox7jf","tag_id":"ck3ioq5jt001glcvdd4z714a0","_id":"ck3ioq5jz001olcvdb7l0mrho"},{"post_id":"ck3ioq5jb000ulcvdbgb0uoei","tag_id":"ck3ioq5jz001nlcvd64epkcds","_id":"ck3ioq5k6001vlcvdydd9zkae"},{"post_id":"ck3ioq5k3001slcvd93f7ruua","tag_id":"ck3ioq5jz001nlcvd64epkcds","_id":"ck3ioq5k8001zlcvd7ii2nmg0"},{"post_id":"ck3ioq5k7001ylcvd7k7qiwm3","tag_id":"ck3ioq5jk0014lcvdd6m3g4kp","_id":"ck3ioq5kc0024lcvdbu7cy5q1"},{"post_id":"ck3ioq5ka0021lcvdtruhfsts","tag_id":"ck3ioq5jk0014lcvdd6m3g4kp","_id":"ck3ioq5ke0028lcvdqzmlvuxf"},{"post_id":"ck3ioq5je000xlcvd2alan9i1","tag_id":"ck3ioq5jz001nlcvd64epkcds","_id":"ck3ioq5kh002clcvdy6p1hjzt"},{"post_id":"ck3ioq5je000xlcvd2alan9i1","tag_id":"ck3ioq5k90020lcvd4ug6eugq","_id":"ck3ioq5kk002glcvdyd3v10vy"},{"post_id":"ck3ioq5kc0025lcvdfpweu2iv","tag_id":"ck3ioq5jk0014lcvdd6m3g4kp","_id":"ck3ioq5km002jlcvdi5az75gg"},{"post_id":"ck3ioq5kf0029lcvdd49rirqi","tag_id":"ck3ioq5k90020lcvd4ug6eugq","_id":"ck3ioq5kp002nlcvdswafnvua"},{"post_id":"ck3ioq5jg0010lcvd5z0e62uz","tag_id":"ck3ioq5jz001nlcvd64epkcds","_id":"ck3ioq5kt002rlcvdj7znhq02"},{"post_id":"ck3ioq5kh002dlcvdk1l1mzca","tag_id":"ck3ioq5k90020lcvd4ug6eugq","_id":"ck3ioq5kw002vlcvdktl2hih1"},{"post_id":"ck3ioq5kk002hlcvdeaq5wtkv","tag_id":"ck3ioq5k90020lcvd4ug6eugq","_id":"ck3ioq5l1002ylcvda66kcqe2"},{"post_id":"ck3ioq5ji0013lcvd7h1c2b5q","tag_id":"ck3ioq5kj002flcvdrrxldxgs","_id":"ck3ioq5l30031lcvd2ous6npi"},{"post_id":"ck3ioq5kn002llcvdfb9vi2fy","tag_id":"ck3ioq5k90020lcvd4ug6eugq","_id":"ck3ioq5l50034lcvdd5g0q7cb"},{"post_id":"ck3ioq5kq002plcvdhq6e7s9n","tag_id":"ck3ioq5k90020lcvd4ug6eugq","_id":"ck3ioq5l70037lcvd7riw6zvo"},{"post_id":"ck3ioq5kt002slcvd3ep0fqze","tag_id":"ck3ioq5jz001nlcvd64epkcds","_id":"ck3ioq5l8003alcvd6zapy3b5"},{"post_id":"ck3ioq5jn0019lcvdc3vwz816","tag_id":"ck3ioq5kq002olcvd4nsotxw7","_id":"ck3ioq5l9003dlcvd3xo0ma27"},{"post_id":"ck3ioq5jp001blcvd0vh1x0ud","tag_id":"ck3ioq5kz002xlcvdie6opkbu","_id":"ck3ioq5la003elcvd0119nioo"},{"post_id":"ck3ioq5jt001hlcvd29noji9u","tag_id":"ck3ioq5l40033lcvdv95jzvzt","_id":"ck3ioq5lb003hlcvdsllu5pbw"},{"post_id":"ck3ioq5jv001jlcvdld8bdgng","tag_id":"ck3ioq5l80039lcvdwsd2j8eq","_id":"ck3ioq5lc003jlcvde4gzxjl9"},{"post_id":"ck3ioq5k0001plcvda7ubdj7w","tag_id":"ck3ioq5l40033lcvdv95jzvzt","_id":"ck3ioq5ld003llcvd3hat88nw"},{"post_id":"ck3ioq5k5001ulcvd8r6otijb","tag_id":"ck3ioq5ld003klcvdw2892lo7","_id":"ck3ioq5lh003rlcvd9tmr83qg"},{"post_id":"ck3ioq5kx002wlcvd4avr5q35","tag_id":"ck3ioq5lf003olcvd0x1auux0","_id":"ck3ioq5lj003ulcvdsqo5hqa6"}],"Tag":[{"name":"JDK的命令行工具","_id":"ck3ioq5ia0003lcvd833c3qwx"},{"name":"面试题","_id":"ck3ioq5ig0008lcvdoxyoyrrl"},{"name":"JVM参数","_id":"ck3ioq5ip000elcvdacr0bdq8"},{"name":"内存溢出","_id":"ck3ioq5ix000llcvdjfa08khd"},{"name":"java基础","_id":"ck3ioq5j8000rlcvdu1u3e0b2"},{"name":"线程","_id":"ck3ioq5jf000ylcvdp11dtxt3"},{"name":"mybatis","_id":"ck3ioq5jk0014lcvdd6m3g4kp"},{"name":"异常","_id":"ck3ioq5jp001alcvdswhrxv5t"},{"name":"mysql","_id":"ck3ioq5jt001glcvdd4z714a0"},{"name":"spring","_id":"ck3ioq5jz001nlcvd64epkcds"},{"name":"设计模式","_id":"ck3ioq5k90020lcvd4ug6eugq"},{"name":"AOP","_id":"ck3ioq5kj002flcvdrrxldxgs"},{"name":"博客搭建","_id":"ck3ioq5kq002olcvd4nsotxw7"},{"name":"HashMap","_id":"ck3ioq5kz002xlcvdie6opkbu"},{"name":"缓存","_id":"ck3ioq5l40033lcvdv95jzvzt"},{"name":"网络基础","_id":"ck3ioq5l80039lcvdwsd2j8eq"},{"name":"框架,面试题","_id":"ck3ioq5ld003klcvdw2892lo7"},{"name":"阻塞队列","_id":"ck3ioq5lf003olcvd0x1auux0"}]}}